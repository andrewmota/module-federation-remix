"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/index.ts
function getIdentifier(path) {
  const parentPath = path.parentPath;
  if (parentPath.type === "VariableDeclarator") {
    const pp = parentPath;
    const name = pp.get("id");
    return name.node.type === "Identifier" ? name : null;
  }
  if (parentPath.type === "AssignmentExpression") {
    const pp = parentPath;
    const name = pp.get("left");
    return name.node.type === "Identifier" ? name : null;
  }
  if (path.node.type === "ArrowFunctionExpression") {
    return null;
  }
  return path.node.id && path.node.id.type === "Identifier" ? path.get("id") : null;
}
function isIdentifierReferenced(ident) {
  const b = ident.scope.getBinding(ident.node.name);
  if (_optionalChain([b, 'optionalAccess', _ => _.referenced])) {
    if (b.path.type === "FunctionDeclaration") {
      return !b.constantViolations.concat(b.referencePaths).every((ref) => ref.findParent((p) => p === b.path));
    }
    return true;
  }
  return false;
}
var createMarkFunction = (state) => function markFunction(path) {
  const ident = getIdentifier(path);
  if (_optionalChain([ident, 'optionalAccess', _2 => _2.node]) && isIdentifierReferenced(ident)) {
    state.refs.add(ident);
  }
};
var createMarkImport = (state) => function markImport(path) {
  const local = path.get("local");
  if (isIdentifierReferenced(local)) {
    state.refs.add(local);
  }
};
function babelPluginEliminator({
  types: t
}) {
  return {
    visitor: {
      Program: {
        enter(path, state) {
          state.refs = new Set();
          state.removedNamedExports = new Set();
          const namedExports = state.opts.namedExports || [];
          const markImport = createMarkImport(state);
          const markFunction = createMarkFunction(state);
          path.traverse({
            VariableDeclarator(variablePath) {
              if (variablePath.node.id.type === "Identifier") {
                const local = variablePath.get("id");
                if (isIdentifierReferenced(local)) {
                  state.refs.add(local);
                }
              } else if (variablePath.node.id.type === "ObjectPattern") {
                const pattern = variablePath.get("id");
                const properties = pattern.get("properties");
                properties.forEach((p) => {
                  const local = p.get(p.node.type === "ObjectProperty" ? "value" : p.node.type === "RestElement" ? "argument" : function() {
                    throw new Error("invariant");
                  }());
                  if (isIdentifierReferenced(local)) {
                    state.refs.add(local);
                  }
                });
              } else if (variablePath.node.id.type === "ArrayPattern") {
                const pattern = variablePath.get("id");
                const elements = pattern.get("elements");
                elements.forEach((e) => {
                  let local;
                  if (_optionalChain([e, 'access', _3 => _3.node, 'optionalAccess', _4 => _4.type]) === "Identifier") {
                    local = e;
                  } else if (_optionalChain([e, 'access', _5 => _5.node, 'optionalAccess', _6 => _6.type]) === "RestElement") {
                    local = e.get("argument");
                  } else {
                    return;
                  }
                  if (isIdentifierReferenced(local)) {
                    state.refs.add(local);
                  }
                });
              }
            },
            FunctionDeclaration: markFunction,
            FunctionExpression: markFunction,
            ArrowFunctionExpression: markFunction,
            ImportSpecifier: markImport,
            ImportDefaultSpecifier: markImport,
            ImportNamespaceSpecifier: markImport,
            ExportNamedDeclaration(path2) {
              const insertIndicator = (path3, exportName) => {
                path3.insertBefore(t.exportNamedDeclaration(t.variableDeclaration("var", [
                  t.variableDeclarator(t.identifier(exportName), t.numericLiteral(1))
                ])));
              };
              let shouldRemove = false;
              path2.node.specifiers = path2.node.specifiers.filter((spec) => {
                if (spec.exported.type !== "Identifier") {
                  return true;
                }
                const {name} = spec.exported;
                for (const namedExport of namedExports) {
                  if (name === namedExport) {
                    insertIndicator(path2, namedExport);
                    state.removedNamedExports.add(namedExport);
                    return false;
                  }
                }
                return true;
              });
              const {declaration} = path2.node;
              if (!declaration && path2.node.specifiers.length === 0) {
                shouldRemove = true;
              }
              if (declaration && declaration.type === "VariableDeclaration") {
                declaration.declarations = declaration.declarations.filter((declarator) => {
                  for (const name of namedExports) {
                    if (declarator.id.name === name && _optionalChain([declarator, 'access', _7 => _7.init, 'optionalAccess', _8 => _8.type, 'access', _9 => _9.includes, 'call', _10 => _10("Function")])) {
                      insertIndicator(path2, name);
                      state.removedNamedExports.add(name);
                      return false;
                    }
                  }
                  return true;
                });
                if (declaration.declarations.length === 0) {
                  shouldRemove = true;
                }
              }
              if (declaration && declaration.type === "FunctionDeclaration") {
                for (const name of namedExports) {
                  if (declaration.id.name === name) {
                    shouldRemove = true;
                    state.removedNamedExports.add(name);
                    insertIndicator(path2, name);
                  }
                }
              }
              if (shouldRemove) {
                path2.remove();
              }
            }
          });
          if (state.removedNamedExports.size === 0) {
            return;
          }
          if (state.opts.done) {
            state.opts.done(state);
          }
          const refs = state.refs;
          let count;
          function sweepFunction(path2) {
            const ident = getIdentifier(path2);
            if (_optionalChain([ident, 'optionalAccess', _11 => _11.node]) && refs.has(ident) && !isIdentifierReferenced(ident)) {
              ++count;
              if (t.isAssignmentExpression(path2.parentPath) || t.isVariableDeclarator(path2.parentPath)) {
                path2.parentPath.remove();
              } else {
                path2.remove();
              }
            }
          }
          function sweepImport(path2) {
            const local = path2.get("local");
            if (refs.has(local) && !isIdentifierReferenced(local)) {
              ++count;
              path2.remove();
              if (path2.parent.specifiers.length === 0) {
                path2.parentPath.remove();
              }
            }
          }
          do {
            ;
            path.scope.crawl();
            count = 0;
            path.traverse({
              VariableDeclarator(variablePath) {
                if (variablePath.node.id.type === "Identifier") {
                  const local = variablePath.get("id");
                  if (refs.has(local) && !isIdentifierReferenced(local)) {
                    ++count;
                    variablePath.remove();
                  }
                } else if (variablePath.node.id.type === "ObjectPattern") {
                  const pattern = variablePath.get("id");
                  const beforeCount = count;
                  const properties = pattern.get("properties");
                  properties.forEach((p) => {
                    const local = p.get(p.node.type === "ObjectProperty" ? "value" : p.node.type === "RestElement" ? "argument" : function() {
                      throw new Error("invariant");
                    }());
                    if (refs.has(local) && !isIdentifierReferenced(local)) {
                      ++count;
                      p.remove();
                    }
                  });
                  if (beforeCount !== count && pattern.get("properties").length < 1) {
                    variablePath.remove();
                  }
                } else if (variablePath.node.id.type === "ArrayPattern") {
                  const pattern = variablePath.get("id");
                  const beforeCount = count;
                  const elements = pattern.get("elements");
                  elements.forEach((e) => {
                    let local;
                    if (_optionalChain([e, 'access', _12 => _12.node, 'optionalAccess', _13 => _13.type]) === "Identifier") {
                      local = e;
                    } else if (_optionalChain([e, 'access', _14 => _14.node, 'optionalAccess', _15 => _15.type]) === "RestElement") {
                      local = e.get("argument");
                    } else {
                      return;
                    }
                    if (refs.has(local) && !isIdentifierReferenced(local)) {
                      ++count;
                      e.remove();
                    }
                  });
                  if (beforeCount !== count && pattern.get("elements").length < 1) {
                    variablePath.remove();
                  }
                }
              },
              FunctionDeclaration: sweepFunction,
              FunctionExpression: sweepFunction,
              ArrowFunctionExpression: sweepFunction,
              ImportSpecifier: sweepImport,
              ImportDefaultSpecifier: sweepImport,
              ImportNamespaceSpecifier: sweepImport
            });
          } while (count);
        }
      }
    }
  };
}


exports.default = babelPluginEliminator;
