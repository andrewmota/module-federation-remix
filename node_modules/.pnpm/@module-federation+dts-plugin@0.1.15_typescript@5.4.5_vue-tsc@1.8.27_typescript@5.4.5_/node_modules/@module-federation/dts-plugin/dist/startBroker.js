"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/dts-plugin/src/server/broker/startBroker.ts
var startBroker_exports = {};
__export(startBroker_exports, {
  getBroker: () => getBroker
});
module.exports = __toCommonJS(startBroker_exports);

// packages/dts-plugin/src/server/broker/Broker.ts
var import_http = require("http");

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var import_managers2 = require("@module-federation/managers");
var import_typescript2 = __toESM(require("typescript"));

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_ansi_colors2 = __toESM(require("ansi-colors"));
var import_sdk4 = require("@module-federation/sdk");
var import_lodash = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var import_adm_zip = __toESM(require("adm-zip"));
var import_axios = __toESM(require("axios"));

// packages/dts-plugin/src/core/lib/typeScriptCompiler.ts
var import_ansi_colors = __toESM(require("ansi-colors"));
var import_typescript = __toESM(require("typescript"));
var import_third_party_dts_extractor = require("@module-federation/third-party-dts-extractor");

// packages/dts-plugin/src/server/message/Message.ts
var Message = class {
  constructor(type, kind) {
    this.type = type;
    this.kind = kind;
    this.time = Date.now();
  }
};

// packages/dts-plugin/src/server/message/API/API.ts
var API = class extends Message {
  constructor(content, kind) {
    super("API", kind);
    const { code, payload } = content;
    this.code = code;
    this.payload = payload;
  }
};

// packages/dts-plugin/src/server/message/API/UpdateSubscriber.ts
var UpdateSubscriberAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "UPDATE_SUBSCRIBER" /* UPDATE_SUBSCRIBER */
    );
  }
};

// packages/dts-plugin/src/server/message/API/ReloadWebClient.ts
var ReloadWebClientAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "RELOAD_WEB_CLIENT" /* RELOAD_WEB_CLIENT */
    );
  }
};

// packages/dts-plugin/src/server/utils/index.ts
var import_sdk2 = require("@module-federation/sdk");

// packages/dts-plugin/src/server/utils/logTransform.ts
var import_chalk = __toESM(require("chalk"));

// packages/dts-plugin/src/server/message/Log/Log.ts
var Log = class extends Message {
  constructor(level, kind, ignoreVerbose = false) {
    super("Log", kind);
    this.ignoreVerbose = false;
    this.level = level;
    this.ignoreVerbose = ignoreVerbose;
  }
};

// packages/dts-plugin/src/server/message/Log/BrokerExitLog.ts
var BrokerExitLog = class extends Log {
  constructor() {
    super("LOG" /* LOG */, "BrokerExitLog" /* BrokerExitLog */);
  }
};

// packages/dts-plugin/src/server/utils/log.ts
var import_sdk = require("@module-federation/sdk");
var log4js = __toESM(require("log4js"));
var import_chalk2 = __toESM(require("chalk"));

// packages/dts-plugin/src/server/constant.ts
var DEFAULT_WEB_SOCKET_PORT = 16322;
var WEB_SOCKET_CONNECT_MAGIC_ID = "1hpzW-zo2z-o8io-gfmV1-2cb1d82";

// packages/dts-plugin/src/server/utils/log.ts
function fileLog(msg, module2, level) {
  var _a, _b;
  if (!((_a = process == null ? void 0 : process.env) == null ? void 0 : _a["FEDERATION_DEBUG"])) {
    return;
  }
  log4js.configure({
    appenders: {
      [module2]: { type: "file", filename: ".mf/typesGenerate.log" },
      default: { type: "file", filename: ".mf/typesGenerate.log" }
    },
    categories: {
      [module2]: { appenders: [module2], level: "error" },
      default: { appenders: ["default"], level: "trace" }
    }
  });
  const logger4 = log4js.getLogger(module2);
  logger4.level = "debug";
  (_b = logger4[level]) == null ? void 0 : _b.call(logger4, msg);
}
function error(error2, action, from) {
  const err = error2 instanceof Error ? error2 : new Error(`${action} error`);
  fileLog(`[${action}] error: ${err}`, from, "fatal");
  return err.toString();
}

// packages/dts-plugin/src/server/utils/index.ts
function getIdentifier(options) {
  const { ip, name } = options;
  return `mf ${import_sdk2.SEPARATOR}${name}${ip ? `${import_sdk2.SEPARATOR}${ip}` : ""}`;
}

// packages/dts-plugin/src/server/Publisher.ts
var Publisher = class {
  constructor(ctx) {
    this._name = ctx.name;
    this._ip = ctx.ip;
    this._remoteTypeTarPath = ctx.remoteTypeTarPath;
    this._subscribers = /* @__PURE__ */ new Map();
  }
  get identifier() {
    return getIdentifier({
      name: this._name,
      ip: this._ip
    });
  }
  get name() {
    return this._name;
  }
  get ip() {
    return this._ip;
  }
  get remoteTypeTarPath() {
    return this._remoteTypeTarPath;
  }
  get hasSubscribes() {
    return Boolean(this._subscribers.size);
  }
  get subscribers() {
    return this._subscribers;
  }
  addSubscriber(identifier, subscriber) {
    fileLog(`${this.name} set subscriber: ${identifier}`, "Publisher", "info");
    this._subscribers.set(identifier, subscriber);
  }
  removeSubscriber(identifier) {
    if (this._subscribers.has(identifier)) {
      fileLog(
        `${this.name} removeSubscriber: ${identifier}`,
        "Publisher",
        "warn"
      );
      this._subscribers.delete(identifier);
    }
  }
  notifySubscriber(subscriberIdentifier, options) {
    const subscriber = this._subscribers.get(subscriberIdentifier);
    if (!subscriber) {
      fileLog(
        `[notifySubscriber] ${this.name} notifySubscriber: ${subscriberIdentifier}, does not exits`,
        "Publisher",
        "error"
      );
      return;
    }
    const api = new UpdateSubscriberAPI(options);
    subscriber.send(JSON.stringify(api));
    fileLog(
      `[notifySubscriber] ${this.name} notifySubscriber: ${JSON.stringify(
        subscriberIdentifier
      )}, message: ${JSON.stringify(api)}`,
      "Publisher",
      "info"
    );
  }
  notifySubscribers(options) {
    const api = new UpdateSubscriberAPI(options);
    this.broadcast(api);
  }
  broadcast(message) {
    if (this.hasSubscribes) {
      this._subscribers.forEach((subscriber, key) => {
        fileLog(
          `[BroadCast] ${this.name} notifySubscriber: ${key}, PID: ${process.pid}, message: ${JSON.stringify(message)}`,
          "Publisher",
          "info"
        );
        subscriber.send(JSON.stringify(message));
      });
    } else {
      fileLog(
        `[BroadCast] ${this.name}'s subscribe is empty`,
        "Publisher",
        "warn"
      );
    }
  }
  close() {
    this._subscribers.forEach((_subscriber, identifier) => {
      fileLog(
        `[BroadCast] close ${this.name} remove: ${identifier}`,
        "Publisher",
        "warn"
      );
      this.removeSubscriber(identifier);
    });
  }
};

// packages/dts-plugin/src/server/DevServer.ts
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));

// packages/dts-plugin/src/server/createKoaServer.ts
var import_fs_extra = __toESM(require("fs-extra"));
var import_koa = __toESM(require("koa"));

// packages/dts-plugin/src/core/configurations/hostPlugin.ts
var import_sdk3 = require("@module-federation/sdk");
var import_managers = require("@module-federation/managers");
var defaultOptions = {
  typesFolder: "@mf-types",
  remoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  maxRetries: 3,
  implementation: "",
  context: process.cwd(),
  abortOnError: true,
  consumeAPITypes: false
};

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_axios2 = __toESM(require("axios"));

// packages/dts-plugin/src/core/lib/utils.ts
var import_ansi_colors3 = __toESM(require("ansi-colors"));

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var defaultOptions2 = {
  tsConfigPath: "./tsconfig.json",
  typesFolder: "@mf-types",
  compiledTypesFolder: "compiled-types",
  hostRemoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  additionalFilesToCompile: [],
  compilerInstance: "tsc",
  compileInChildProcess: false,
  implementation: "",
  generateAPITypes: false,
  context: process.cwd(),
  abortOnError: true,
  extractRemoteTypes: false,
  extractThirdParty: false
};

// packages/dts-plugin/src/core/lib/DtsWorker.ts
var import_lodash2 = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/server/broker/Broker.ts
var import_isomorphic_ws2 = __toESM(require("isomorphic-ws"));
var import_node_schedule = __toESM(require("node-schedule"));
var import_url = require("url");
var _Broker = class _Broker {
  constructor() {
    // 1.5h
    this._publisherMap = /* @__PURE__ */ new Map();
    this._webClientMap = /* @__PURE__ */ new Map();
    this._tmpSubscriberShelter = /* @__PURE__ */ new Map();
    this._scheduleJob = null;
    this._setSchedule();
    this._startWsServer();
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
  }
  get hasPublishers() {
    return Boolean(this._publisherMap.size);
  }
  async _startWsServer() {
    const wsHandler = (ws, req) => {
      const { url: reqUrl = "" } = req;
      const { query } = (0, import_url.parse)(reqUrl, true);
      const { WEB_SOCKET_CONNECT_MAGIC_ID: WEB_SOCKET_CONNECT_MAGIC_ID2 } = query;
      if (WEB_SOCKET_CONNECT_MAGIC_ID2 === _Broker.WEB_SOCKET_CONNECT_MAGIC_ID) {
        ws.on("message", (message) => {
          try {
            const text = message.toString();
            const action = JSON.parse(text);
            fileLog(`${action == null ? void 0 : action.kind} action received `, "Broker", "info");
            this._takeAction(action, ws);
          } catch (error2) {
            fileLog(`parse action message error: ${error2}`, "Broker", "error");
          }
        });
        ws.on("error", (e) => {
          fileLog(`parse action message error: ${e}`, "Broker", "error");
        });
      } else {
        ws.send("Invalid CONNECT ID.");
        fileLog("Invalid CONNECT ID.", "Broker", "warn");
        ws.close();
      }
    };
    const server = (0, import_http.createServer)();
    this._webSocketServer = new import_isomorphic_ws2.default.Server({ noServer: true });
    this._webSocketServer.on("error", (err) => {
      fileLog(`ws error: 
${err.message}
 ${err.stack}`, "Broker", "error");
    });
    this._webSocketServer.on("listening", () => {
      fileLog(
        `WebSocket server is listening on port ${_Broker.DEFAULT_WEB_SOCKET_PORT}`,
        "Broker",
        "info"
      );
    });
    this._webSocketServer.on("connection", wsHandler);
    this._webSocketServer.on("close", (code) => {
      fileLog(`WebSocket Server Close with Code ${code}`, "Broker", "warn");
      this._webSocketServer && this._webSocketServer.close();
      this._webSocketServer = void 0;
    });
    server.on("upgrade", (req, socket, head) => {
      var _a;
      if (req.url) {
        const { pathname } = (0, import_url.parse)(req.url);
        if (pathname === "/") {
          (_a = this._webSocketServer) == null ? void 0 : _a.handleUpgrade(req, socket, head, (ws) => {
            var _a2;
            (_a2 = this._webSocketServer) == null ? void 0 : _a2.emit("connection", ws, req);
          });
        }
      }
    });
    server.listen(_Broker.DEFAULT_WEB_SOCKET_PORT);
  }
  async _takeAction(action, client) {
    const { kind, payload } = action;
    if (kind === "ADD_PUBLISHER" /* ADD_PUBLISHER */) {
      await this._addPublisher(payload, client);
    }
    if (kind === "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */) {
      await this._updatePublisher(
        payload,
        client
      );
    }
    if (kind === "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */) {
      await this._addSubscriber(payload, client);
    }
    if (kind === "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */) {
      await this._removeSubscriber(
        payload,
        client
      );
    }
    if (kind === "EXIT_PUBLISHER" /* EXIT_PUBLISHER */) {
      await this._removePublisher(payload, client);
    }
    if (kind === "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */) {
      await this._addWebClient(payload, client);
    }
    if (kind === "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */) {
      await this._notifyWebClient(
        payload,
        client
      );
    }
  }
  async _addPublisher(context, client) {
    const { name, ip, remoteTypeTarPath } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (this._publisherMap.has(identifier)) {
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} has been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = new Publisher({ name, ip, remoteTypeTarPath });
      this._publisherMap.set(identifier, publisher);
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} Adding Publisher Succeed`,
        "Broker",
        "info"
      );
      const tmpSubScribers = this._getTmpSubScribers(identifier);
      if (tmpSubScribers) {
        fileLog(
          `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] consumeTmpSubscriber set ${publisher.name}\u2019s subscribers `,
          "Broker",
          "info"
        );
        this._consumeTmpSubScribers(publisher, tmpSubScribers);
        this._clearTmpSubScriberRelation(identifier);
      }
    } catch (err) {
      const msg = error(err, "ADD_PUBLISHER" /* ADD_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _updatePublisher(context, client) {
    const {
      name,
      updateMode,
      updateKind,
      updateSourcePaths,
      remoteTypeTarPath,
      ip
    } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (!this._publisherMap.has(identifier)) {
      fileLog(
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} has not been started, this action will be ignored
        this._publisherMap: ${JSON.stringify(this._publisherMap.entries())}
        `,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = this._publisherMap.get(identifier);
      fileLog(
        // eslint-disable-next-line max-len
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} update, and notify subscribers to update`,
        "Broker",
        "info"
      );
      if (publisher) {
        publisher.notifySubscribers({
          remoteTypeTarPath,
          name,
          updateMode,
          updateKind,
          updateSourcePaths: updateSourcePaths || []
        });
      }
    } catch (err) {
      const msg = error(err, "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  //  app1 consumes provider1,provider2. Dependencies at this time: publishers: [provider1, provider2], subscriberName: app1
  // provider1 is app1's remote
  async _addSubscriber(context, client) {
    const { publishers, name: subscriberName } = context ?? {};
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({ name, ip });
      if (!this._publisherMap.has(identifier)) {
        fileLog(
          `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has not been started, ${subscriberName} will add the relation to tmp shelter`,
          "Broker",
          "warn"
        );
        this._addTmpSubScriberRelation(
          {
            name: getIdentifier({
              name: context.name,
              ip: context.ip
            }),
            client
          },
          publisher
        );
        return;
      }
      try {
        const registeredPublisher = this._publisherMap.get(identifier);
        if (registeredPublisher) {
          registeredPublisher.addSubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            client
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has been started, Adding Subscriber ${subscriberName} Succeed, this.__publisherMap are: ${JSON.stringify(
              Array.from(this._publisherMap.entries())
            )}`,
            "Broker",
            "info"
          );
          registeredPublisher.notifySubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            {
              updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
              updateMode: "PASSIVE" /* PASSIVE */,
              updateSourcePaths: [registeredPublisher.name],
              remoteTypeTarPath: registeredPublisher.remoteTypeTarPath,
              name: registeredPublisher.name
            }
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: notifySubscriber Subscriber ${subscriberName}, updateMode: "PASSIVE",  updateSourcePaths: ${registeredPublisher.name}`,
            "Broker",
            "info"
          );
        }
      } catch (err) {
        const msg = error(err, "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  // Trigger while consumer exit
  async _removeSubscriber(context, client) {
    const { publishers } = context ?? {};
    const subscriberIdentifier = getIdentifier({
      name: context == null ? void 0 : context.name,
      ip: context == null ? void 0 : context.ip
    });
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({
        name,
        ip
      });
      const registeredPublisher = this._publisherMap.get(identifier);
      if (!registeredPublisher) {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} does not exit `,
          "Broker",
          "warn"
        );
        return;
      }
      try {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} will exit `,
          "Broker",
          "INFO"
        );
        registeredPublisher.removeSubscriber(subscriberIdentifier);
        this._clearTmpSubScriberRelation(identifier);
        if (!registeredPublisher.hasSubscribes) {
          this._publisherMap.delete(identifier);
        }
        if (!this.hasPublishers) {
          this.exit();
        }
      } catch (err) {
        const msg = error(err, "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  async _removePublisher(context, client) {
    const { name, ip } = context ?? {};
    const identifier = getIdentifier({
      name,
      ip
    });
    const publisher = this._publisherMap.get(identifier);
    if (!publisher) {
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier}} has not been added, this action will be ingored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const { subscribers } = publisher;
      subscribers.forEach((subscriber, subscriberIdentifier) => {
        this._addTmpSubScriberRelation(
          {
            name: subscriberIdentifier,
            client: subscriber
          },
          { name: publisher.name, ip: publisher.ip }
        );
        fileLog(
          // eslint-disable-next-line max-len
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removing , subscriber: ${subscriberIdentifier} will be add  tmpSubScriberRelation`,
          "Broker",
          "info"
        );
      });
      this._publisherMap.delete(identifier);
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removed `,
        "Broker",
        "info"
      );
      if (!this.hasPublishers) {
        fileLog(
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: _publisherMap is empty, all server will exit `,
          "Broker",
          "warn"
        );
        this.exit();
      }
    } catch (err) {
      const msg = error(err, "EXIT_PUBLISHER" /* EXIT_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _addWebClient(context, client) {
    const { name } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    if (this._webClientMap.has(identifier)) {
      fileLog(
        `${identifier}} has been added, this action will override prev WebClient`,
        "Broker",
        "warn"
      );
    }
    try {
      this._webClientMap.set(identifier, client);
      fileLog(`${identifier} adding WebClient Succeed`, "Broker", "info");
    } catch (err) {
      const msg = error(err, "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _notifyWebClient(context, client) {
    const { name, updateMode } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    const webClient = this._webClientMap.get(identifier);
    if (!webClient) {
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] ${identifier} has not been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const api = new ReloadWebClientAPI({ name, updateMode });
      webClient.send(JSON.stringify(api));
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] Notify ${name} WebClient Succeed`,
        "Broker",
        "info"
      );
    } catch (err) {
      const msg = error(err, "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  // app1 consumes provider1, and provider1 not launch. this._tmpSubscriberShelter at this time: {provider1: Map{subscribers: Map{app1: app1+ip+client'}, timestamp: 'xx'} }
  _addTmpSubScriberRelation(subscriber, publisher) {
    const publisherIdentifier = getIdentifier({
      name: publisher.name,
      ip: publisher.ip
    });
    const subscriberIdentifier = subscriber.name;
    const shelter = this._tmpSubscriberShelter.get(publisherIdentifier);
    if (!shelter) {
      const map = /* @__PURE__ */ new Map();
      map.set(subscriberIdentifier, subscriber);
      this._tmpSubscriberShelter.set(publisherIdentifier, {
        subscribers: map,
        timestamp: Date.now()
      });
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier}'s subscriber has ${subscriberIdentifier} `,
        "Broker",
        "info"
      );
      return;
    }
    const tmpSubScriberShelterSubscriber = shelter.subscribers.get(subscriberIdentifier);
    if (tmpSubScriberShelterSubscriber) {
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier} and ${subscriberIdentifier} relation has been added`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
      shelter.timestamp = Date.now();
    } else {
      fileLog(
        // eslint-disable-next-line max-len
        `AddTmpSubscriberLog ${publisherIdentifier}'s shelter has been added, update shelter.subscribers ${subscriberIdentifier}`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
    }
  }
  _getTmpSubScribers(publisherIdentifier) {
    var _a;
    return (_a = this._tmpSubscriberShelter.get(publisherIdentifier)) == null ? void 0 : _a.subscribers;
  }
  // after adding publisher, it will change the temp subscriber to regular subscriber
  _consumeTmpSubScribers(publisher, tmpSubScribers) {
    tmpSubScribers.forEach((tmpSubScriber, identifier) => {
      fileLog(
        `notifyTmpSubScribers ${publisher.name} will be add a subscriber: ${identifier} `,
        "Broker",
        "warn"
      );
      publisher.addSubscriber(identifier, tmpSubScriber.client);
      publisher.notifySubscriber(identifier, {
        updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
        updateMode: "PASSIVE" /* PASSIVE */,
        updateSourcePaths: [publisher.name],
        remoteTypeTarPath: publisher.remoteTypeTarPath,
        name: publisher.name
      });
    });
  }
  _clearTmpSubScriberRelation(identifier) {
    this._tmpSubscriberShelter.delete(identifier);
  }
  _clearTmpSubScriberRelations() {
    this._tmpSubscriberShelter.clear();
  }
  _disconnect() {
    this._publisherMap.forEach((publisher) => {
      publisher.close();
    });
  }
  // Every day on 0/6/9/12/15//18, Publishers that have not been connected within 1.5 hours will be cleared regularly.
  // If process.env.FEDERATION_SERVER_TEST is set, it will be read at a specified time.
  _setSchedule() {
    const rule = new import_node_schedule.default.RecurrenceRule();
    if (Number(process.env["FEDERATION_SERVER_TEST"])) {
      const interval = Number(process.env["FEDERATION_SERVER_TEST"]) / 1e3;
      const second = [];
      for (let i = 0; i < 60; i = i + interval) {
        second.push(i);
      }
      rule.second = second;
    } else {
      rule.second = 0;
      rule.hour = [0, 3, 6, 9, 12, 15, 18];
      rule.minute = 0;
    }
    const serverTest = Number(process.env["FEDERATION_SERVER_TEST"]);
    this._scheduleJob = import_node_schedule.default.scheduleJob(rule, () => {
      this._tmpSubscriberShelter.forEach((tmpSubscriber, identifier) => {
        fileLog(
          ` _clearTmpSubScriberRelation ${identifier},  ${Date.now() - tmpSubscriber.timestamp >= (process.env["GARFISH_MODULE_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)}`,
          "Broker",
          "info"
        );
        if (Date.now() - tmpSubscriber.timestamp >= (process.env["FEDERATION_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)) {
          this._clearTmpSubScriberRelation(identifier);
        }
      });
    });
  }
  _clearSchedule() {
    if (!this._scheduleJob) {
      return;
    }
    this._scheduleJob.cancel();
    this._scheduleJob = null;
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      this.exit();
    });
    process.on("SIGINT", () => {
      this.exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
    process.on("uncaughtException", (error2) => {
      console.error("Unhandled Exception Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
  }
  async start() {
  }
  exit() {
    const brokerExitLog = new BrokerExitLog();
    this.broadcast(JSON.stringify(brokerExitLog));
    this._disconnect();
    this._clearSchedule();
    this._clearTmpSubScriberRelations();
    this._webSocketServer && this._webSocketServer.close();
    this._secureWebSocketServer && this._secureWebSocketServer.close();
    process.exit(0);
  }
  broadcast(message) {
    var _a, _b;
    fileLog(
      `[broadcast] exit info : ${JSON.stringify(message)}`,
      "Broker",
      "warn"
    );
    (_a = this._webSocketServer) == null ? void 0 : _a.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
    (_b = this._secureWebSocketServer) == null ? void 0 : _b.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
  }
};
_Broker.WEB_SOCKET_CONNECT_MAGIC_ID = WEB_SOCKET_CONNECT_MAGIC_ID;
_Broker.DEFAULT_WEB_SOCKET_PORT = DEFAULT_WEB_SOCKET_PORT;
_Broker.DEFAULT_SECURE_WEB_SOCKET_PORT = 16324;
_Broker.DEFAULT_WAITING_TIME = 1.5 * 60 * 60 * 1e3;
var Broker = _Broker;

// packages/dts-plugin/src/server/broker/startBroker.ts
var broker;
function getBroker() {
  return broker;
}
async function startBroker() {
  var _a;
  if (getBroker()) {
    return;
  }
  broker = new Broker();
  await broker.start();
  (_a = process.send) == null ? void 0 : _a.call(process, "ready");
}
process.on("message", (message) => {
  if (message === "start") {
    fileLog(`startBroker... ${process.pid}`, "StartBroker", "info");
    startBroker();
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getBroker
});
