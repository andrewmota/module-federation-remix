"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/dts-plugin/src/index.ts
var src_exports = {};
__export(src_exports, {
  DtsPlugin: () => DtsPlugin
});
module.exports = __toCommonJS(src_exports);

// packages/dts-plugin/src/plugins/DevPlugin.ts
var import_fs_extra2 = __toESM(require("fs-extra"));
var import_chalk3 = __toESM(require("chalk"));

// packages/dts-plugin/src/dev-worker/createDevWorker.ts
var path5 = __toESM(require("path"));
var fse = __toESM(require("fs-extra"));

// packages/dts-plugin/src/dev-worker/DevWorker.ts
var import_path7 = __toESM(require("path"));
var import_lodash3 = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var import_fs3 = require("fs");
var import_path5 = require("path");
var import_managers2 = require("@module-federation/managers");
var import_typescript2 = __toESM(require("typescript"));

// packages/dts-plugin/src/core/lib/utils.ts
var import_path4 = __toESM(require("path"));

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_ansi_colors2 = __toESM(require("ansi-colors"));
var import_path3 = __toESM(require("path"));
var import_promises = require("fs/promises");
var import_fs = __toESM(require("fs"));
var import_sdk4 = require("@module-federation/sdk");
var import_lodash = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var import_adm_zip = __toESM(require("adm-zip"));
var import_axios = __toESM(require("axios"));
var import_path2 = require("path");

// packages/dts-plugin/src/core/lib/typeScriptCompiler.ts
var import_ansi_colors = __toESM(require("ansi-colors"));
var import_path = require("path");
var import_typescript = __toESM(require("typescript"));
var import_third_party_dts_extractor = require("@module-federation/third-party-dts-extractor");
var STARTS_WITH_SLASH = /^\//;
var DEFINITION_FILE_EXTENSION = ".d.ts";
var reportCompileDiagnostic = (diagnostic) => {
  const { line } = diagnostic.file.getLineAndCharacterOfPosition(
    diagnostic.start
  );
  console.error(
    import_ansi_colors.default.red(
      `TS Error ${diagnostic.code}':' ${import_typescript.default.flattenDiagnosticMessageText(
        diagnostic.messageText,
        import_typescript.default.sys.newLine
      )}`
    )
  );
  console.error(
    import_ansi_colors.default.red(
      `         at ${diagnostic.file.fileName}:${line + 1} typescript.sys.newLine`
    )
  );
};
var retrieveMfTypesPath = (tsConfig, remoteOptions) => (0, import_path.normalize)(tsConfig.outDir.replace(remoteOptions.compiledTypesFolder, ""));
var retrieveOriginalOutDir = (tsConfig, remoteOptions) => (0, import_path.normalize)(
  tsConfig.outDir.replace(remoteOptions.compiledTypesFolder, "").replace(remoteOptions.typesFolder, "")
);
var retrieveMfAPITypesPath = (tsConfig, remoteOptions) => (0, import_path.join)(
  retrieveOriginalOutDir(tsConfig, remoteOptions),
  `${remoteOptions.typesFolder}.d.ts`
);
var createHost = (mapComponentsToExpose, tsConfig, remoteOptions, cb) => {
  const host = import_typescript.default.createCompilerHost(tsConfig);
  const originalWriteFile = host.writeFile;
  const mapExposeToEntry = Object.fromEntries(
    Object.entries(mapComponentsToExpose).map(([exposed, filename]) => [
      (0, import_path.normalize)(filename),
      exposed
    ])
  );
  const mfTypePath = retrieveMfTypesPath(tsConfig, remoteOptions);
  host.writeFile = (filepath, text, writeOrderByteMark, onError, sourceFiles, data) => {
    originalWriteFile(
      filepath,
      text,
      writeOrderByteMark,
      onError,
      sourceFiles,
      data
    );
    for (const sourceFile of sourceFiles || []) {
      const sourceEntry = mapExposeToEntry[(0, import_path.normalize)(sourceFile.fileName)];
      if (sourceEntry) {
        const mfeTypeEntry = (0, import_path.join)(
          mfTypePath,
          `${sourceEntry}${DEFINITION_FILE_EXTENSION}`
        );
        const mfeTypeEntryDirectory = (0, import_path.dirname)(mfeTypeEntry);
        const relativePathToOutput = (0, import_path.relative)(mfeTypeEntryDirectory, filepath).replace(DEFINITION_FILE_EXTENSION, "").replace(STARTS_WITH_SLASH, "").split(import_path.sep).join("/");
        originalWriteFile(
          mfeTypeEntry,
          `export * from './${relativePathToOutput}';
export { default } from './${relativePathToOutput}';`,
          writeOrderByteMark
        );
      }
    }
    cb(text);
  };
  return host;
};
var createVueTscProgram = (programOptions) => {
  const vueTypescript = require("vue-tsc");
  return vueTypescript.createProgram(programOptions);
};
var createProgram = (remoteOptions, programOptions) => {
  switch (remoteOptions.compilerInstance) {
    case "vue-tsc":
      return createVueTscProgram(programOptions);
    case "tsc":
    default:
      return import_typescript.default.createProgram(programOptions);
  }
};
var compileTs = (mapComponentsToExpose, tsConfig, remoteOptions) => {
  const mfTypePath = retrieveMfTypesPath(tsConfig, remoteOptions);
  const thirdPartyExtractor = new import_third_party_dts_extractor.ThirdPartyExtractor(
    (0, import_path.resolve)(mfTypePath, "node_modules"),
    remoteOptions.context
  );
  const cb = remoteOptions.extractThirdParty ? thirdPartyExtractor.collectPkgs.bind(thirdPartyExtractor) : () => void 0;
  const tsHost = createHost(mapComponentsToExpose, tsConfig, remoteOptions, cb);
  const filesToCompile = [
    ...Object.values(mapComponentsToExpose),
    ...remoteOptions.additionalFilesToCompile
  ];
  const programOptions = {
    rootNames: filesToCompile,
    host: tsHost,
    options: tsConfig
  };
  const tsProgram = createProgram(remoteOptions, programOptions);
  const { diagnostics = [] } = tsProgram.emit();
  diagnostics.forEach(reportCompileDiagnostic);
  if (remoteOptions.extractThirdParty) {
    thirdPartyExtractor.copyDts();
  }
};

// packages/dts-plugin/src/server/message/Message.ts
var Message = class {
  constructor(type, kind) {
    this.type = type;
    this.kind = kind;
    this.time = Date.now();
  }
};

// packages/dts-plugin/src/server/message/API/API.ts
var API = class extends Message {
  constructor(content, kind) {
    super("API", kind);
    const { code, payload } = content;
    this.code = code;
    this.payload = payload;
  }
};

// packages/dts-plugin/src/server/message/API/UpdateSubscriber.ts
var UpdateSubscriberAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "UPDATE_SUBSCRIBER" /* UPDATE_SUBSCRIBER */
    );
  }
};

// packages/dts-plugin/src/server/message/API/ReloadWebClient.ts
var ReloadWebClientAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "RELOAD_WEB_CLIENT" /* RELOAD_WEB_CLIENT */
    );
  }
};

// packages/dts-plugin/src/server/utils/index.ts
var import_sdk2 = require("@module-federation/sdk");

// packages/dts-plugin/src/server/utils/logTransform.ts
var import_chalk = __toESM(require("chalk"));

// packages/dts-plugin/src/server/message/Log/Log.ts
var Log = class extends Message {
  constructor(level, kind, ignoreVerbose = false) {
    super("Log", kind);
    this.ignoreVerbose = false;
    this.level = level;
    this.ignoreVerbose = ignoreVerbose;
  }
};

// packages/dts-plugin/src/server/message/Log/BrokerExitLog.ts
var BrokerExitLog = class extends Log {
  constructor() {
    super("LOG" /* LOG */, "BrokerExitLog" /* BrokerExitLog */);
  }
};

// packages/dts-plugin/src/server/utils/log.ts
var import_sdk = require("@module-federation/sdk");
var log4js = __toESM(require("log4js"));
var import_chalk2 = __toESM(require("chalk"));

// packages/dts-plugin/src/server/constant.ts
var DEFAULT_WEB_SOCKET_PORT = 16322;
var WEB_SOCKET_CONNECT_MAGIC_ID = "1hpzW-zo2z-o8io-gfmV1-2cb1d82";
var WEB_CLIENT_OPTIONS_IDENTIFIER = "__WEB_CLIENT_OPTIONS__";

// packages/dts-plugin/src/server/utils/log.ts
function fileLog(msg, module2, level) {
  var _a, _b;
  if (!((_a = process == null ? void 0 : process.env) == null ? void 0 : _a["FEDERATION_DEBUG"])) {
    return;
  }
  log4js.configure({
    appenders: {
      [module2]: { type: "file", filename: ".mf/typesGenerate.log" },
      default: { type: "file", filename: ".mf/typesGenerate.log" }
    },
    categories: {
      [module2]: { appenders: [module2], level: "error" },
      default: { appenders: ["default"], level: "trace" }
    }
  });
  const logger4 = log4js.getLogger(module2);
  logger4.level = "debug";
  (_b = logger4[level]) == null ? void 0 : _b.call(logger4, msg);
}
function error(error2, action, from) {
  const err = error2 instanceof Error ? error2 : new Error(`${action} error`);
  fileLog(`[${action}] error: ${err}`, from, "fatal");
  return err.toString();
}

// packages/dts-plugin/src/server/utils/index.ts
function getIdentifier(options) {
  const { ip, name } = options;
  return `mf ${import_sdk2.SEPARATOR}${name}${ip ? `${import_sdk2.SEPARATOR}${ip}` : ""}`;
}

// packages/dts-plugin/src/server/Publisher.ts
var Publisher = class {
  constructor(ctx) {
    this._name = ctx.name;
    this._ip = ctx.ip;
    this._remoteTypeTarPath = ctx.remoteTypeTarPath;
    this._subscribers = /* @__PURE__ */ new Map();
  }
  get identifier() {
    return getIdentifier({
      name: this._name,
      ip: this._ip
    });
  }
  get name() {
    return this._name;
  }
  get ip() {
    return this._ip;
  }
  get remoteTypeTarPath() {
    return this._remoteTypeTarPath;
  }
  get hasSubscribes() {
    return Boolean(this._subscribers.size);
  }
  get subscribers() {
    return this._subscribers;
  }
  addSubscriber(identifier, subscriber) {
    fileLog(`${this.name} set subscriber: ${identifier}`, "Publisher", "info");
    this._subscribers.set(identifier, subscriber);
  }
  removeSubscriber(identifier) {
    if (this._subscribers.has(identifier)) {
      fileLog(
        `${this.name} removeSubscriber: ${identifier}`,
        "Publisher",
        "warn"
      );
      this._subscribers.delete(identifier);
    }
  }
  notifySubscriber(subscriberIdentifier, options) {
    const subscriber = this._subscribers.get(subscriberIdentifier);
    if (!subscriber) {
      fileLog(
        `[notifySubscriber] ${this.name} notifySubscriber: ${subscriberIdentifier}, does not exits`,
        "Publisher",
        "error"
      );
      return;
    }
    const api = new UpdateSubscriberAPI(options);
    subscriber.send(JSON.stringify(api));
    fileLog(
      `[notifySubscriber] ${this.name} notifySubscriber: ${JSON.stringify(
        subscriberIdentifier
      )}, message: ${JSON.stringify(api)}`,
      "Publisher",
      "info"
    );
  }
  notifySubscribers(options) {
    const api = new UpdateSubscriberAPI(options);
    this.broadcast(api);
  }
  broadcast(message) {
    if (this.hasSubscribes) {
      this._subscribers.forEach((subscriber, key) => {
        fileLog(
          `[BroadCast] ${this.name} notifySubscriber: ${key}, PID: ${process.pid}, message: ${JSON.stringify(message)}`,
          "Publisher",
          "info"
        );
        subscriber.send(JSON.stringify(message));
      });
    } else {
      fileLog(
        `[BroadCast] ${this.name}'s subscribe is empty`,
        "Publisher",
        "warn"
      );
    }
  }
  close() {
    this._subscribers.forEach((_subscriber, identifier) => {
      fileLog(
        `[BroadCast] close ${this.name} remove: ${identifier}`,
        "Publisher",
        "warn"
      );
      this.removeSubscriber(identifier);
    });
  }
};

// packages/dts-plugin/src/server/DevServer.ts
var import_isomorphic_ws2 = __toESM(require("isomorphic-ws"));

// packages/dts-plugin/src/server/broker/Broker.ts
var import_http = require("http");
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_node_schedule = __toESM(require("node-schedule"));
var import_url = require("url");
var _Broker = class _Broker {
  constructor() {
    // 1.5h
    this._publisherMap = /* @__PURE__ */ new Map();
    this._webClientMap = /* @__PURE__ */ new Map();
    this._tmpSubscriberShelter = /* @__PURE__ */ new Map();
    this._scheduleJob = null;
    this._setSchedule();
    this._startWsServer();
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
  }
  get hasPublishers() {
    return Boolean(this._publisherMap.size);
  }
  async _startWsServer() {
    const wsHandler = (ws, req) => {
      const { url: reqUrl = "" } = req;
      const { query } = (0, import_url.parse)(reqUrl, true);
      const { WEB_SOCKET_CONNECT_MAGIC_ID: WEB_SOCKET_CONNECT_MAGIC_ID2 } = query;
      if (WEB_SOCKET_CONNECT_MAGIC_ID2 === _Broker.WEB_SOCKET_CONNECT_MAGIC_ID) {
        ws.on("message", (message) => {
          try {
            const text = message.toString();
            const action = JSON.parse(text);
            fileLog(`${action == null ? void 0 : action.kind} action received `, "Broker", "info");
            this._takeAction(action, ws);
          } catch (error2) {
            fileLog(`parse action message error: ${error2}`, "Broker", "error");
          }
        });
        ws.on("error", (e) => {
          fileLog(`parse action message error: ${e}`, "Broker", "error");
        });
      } else {
        ws.send("Invalid CONNECT ID.");
        fileLog("Invalid CONNECT ID.", "Broker", "warn");
        ws.close();
      }
    };
    const server = (0, import_http.createServer)();
    this._webSocketServer = new import_isomorphic_ws.default.Server({ noServer: true });
    this._webSocketServer.on("error", (err) => {
      fileLog(`ws error: 
${err.message}
 ${err.stack}`, "Broker", "error");
    });
    this._webSocketServer.on("listening", () => {
      fileLog(
        `WebSocket server is listening on port ${_Broker.DEFAULT_WEB_SOCKET_PORT}`,
        "Broker",
        "info"
      );
    });
    this._webSocketServer.on("connection", wsHandler);
    this._webSocketServer.on("close", (code) => {
      fileLog(`WebSocket Server Close with Code ${code}`, "Broker", "warn");
      this._webSocketServer && this._webSocketServer.close();
      this._webSocketServer = void 0;
    });
    server.on("upgrade", (req, socket, head) => {
      var _a;
      if (req.url) {
        const { pathname } = (0, import_url.parse)(req.url);
        if (pathname === "/") {
          (_a = this._webSocketServer) == null ? void 0 : _a.handleUpgrade(req, socket, head, (ws) => {
            var _a2;
            (_a2 = this._webSocketServer) == null ? void 0 : _a2.emit("connection", ws, req);
          });
        }
      }
    });
    server.listen(_Broker.DEFAULT_WEB_SOCKET_PORT);
  }
  async _takeAction(action, client) {
    const { kind, payload } = action;
    if (kind === "ADD_PUBLISHER" /* ADD_PUBLISHER */) {
      await this._addPublisher(payload, client);
    }
    if (kind === "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */) {
      await this._updatePublisher(
        payload,
        client
      );
    }
    if (kind === "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */) {
      await this._addSubscriber(payload, client);
    }
    if (kind === "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */) {
      await this._removeSubscriber(
        payload,
        client
      );
    }
    if (kind === "EXIT_PUBLISHER" /* EXIT_PUBLISHER */) {
      await this._removePublisher(payload, client);
    }
    if (kind === "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */) {
      await this._addWebClient(payload, client);
    }
    if (kind === "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */) {
      await this._notifyWebClient(
        payload,
        client
      );
    }
  }
  async _addPublisher(context, client) {
    const { name, ip, remoteTypeTarPath } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (this._publisherMap.has(identifier)) {
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} has been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = new Publisher({ name, ip, remoteTypeTarPath });
      this._publisherMap.set(identifier, publisher);
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} Adding Publisher Succeed`,
        "Broker",
        "info"
      );
      const tmpSubScribers = this._getTmpSubScribers(identifier);
      if (tmpSubScribers) {
        fileLog(
          `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] consumeTmpSubscriber set ${publisher.name}\u2019s subscribers `,
          "Broker",
          "info"
        );
        this._consumeTmpSubScribers(publisher, tmpSubScribers);
        this._clearTmpSubScriberRelation(identifier);
      }
    } catch (err) {
      const msg = error(err, "ADD_PUBLISHER" /* ADD_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _updatePublisher(context, client) {
    const {
      name,
      updateMode,
      updateKind,
      updateSourcePaths,
      remoteTypeTarPath,
      ip
    } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (!this._publisherMap.has(identifier)) {
      fileLog(
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} has not been started, this action will be ignored
        this._publisherMap: ${JSON.stringify(this._publisherMap.entries())}
        `,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = this._publisherMap.get(identifier);
      fileLog(
        // eslint-disable-next-line max-len
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} update, and notify subscribers to update`,
        "Broker",
        "info"
      );
      if (publisher) {
        publisher.notifySubscribers({
          remoteTypeTarPath,
          name,
          updateMode,
          updateKind,
          updateSourcePaths: updateSourcePaths || []
        });
      }
    } catch (err) {
      const msg = error(err, "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  //  app1 consumes provider1,provider2. Dependencies at this time: publishers: [provider1, provider2], subscriberName: app1
  // provider1 is app1's remote
  async _addSubscriber(context, client) {
    const { publishers, name: subscriberName } = context ?? {};
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({ name, ip });
      if (!this._publisherMap.has(identifier)) {
        fileLog(
          `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has not been started, ${subscriberName} will add the relation to tmp shelter`,
          "Broker",
          "warn"
        );
        this._addTmpSubScriberRelation(
          {
            name: getIdentifier({
              name: context.name,
              ip: context.ip
            }),
            client
          },
          publisher
        );
        return;
      }
      try {
        const registeredPublisher = this._publisherMap.get(identifier);
        if (registeredPublisher) {
          registeredPublisher.addSubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            client
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has been started, Adding Subscriber ${subscriberName} Succeed, this.__publisherMap are: ${JSON.stringify(
              Array.from(this._publisherMap.entries())
            )}`,
            "Broker",
            "info"
          );
          registeredPublisher.notifySubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            {
              updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
              updateMode: "PASSIVE" /* PASSIVE */,
              updateSourcePaths: [registeredPublisher.name],
              remoteTypeTarPath: registeredPublisher.remoteTypeTarPath,
              name: registeredPublisher.name
            }
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: notifySubscriber Subscriber ${subscriberName}, updateMode: "PASSIVE",  updateSourcePaths: ${registeredPublisher.name}`,
            "Broker",
            "info"
          );
        }
      } catch (err) {
        const msg = error(err, "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  // Trigger while consumer exit
  async _removeSubscriber(context, client) {
    const { publishers } = context ?? {};
    const subscriberIdentifier = getIdentifier({
      name: context == null ? void 0 : context.name,
      ip: context == null ? void 0 : context.ip
    });
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({
        name,
        ip
      });
      const registeredPublisher = this._publisherMap.get(identifier);
      if (!registeredPublisher) {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} does not exit `,
          "Broker",
          "warn"
        );
        return;
      }
      try {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} will exit `,
          "Broker",
          "INFO"
        );
        registeredPublisher.removeSubscriber(subscriberIdentifier);
        this._clearTmpSubScriberRelation(identifier);
        if (!registeredPublisher.hasSubscribes) {
          this._publisherMap.delete(identifier);
        }
        if (!this.hasPublishers) {
          this.exit();
        }
      } catch (err) {
        const msg = error(err, "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  async _removePublisher(context, client) {
    const { name, ip } = context ?? {};
    const identifier = getIdentifier({
      name,
      ip
    });
    const publisher = this._publisherMap.get(identifier);
    if (!publisher) {
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier}} has not been added, this action will be ingored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const { subscribers } = publisher;
      subscribers.forEach((subscriber, subscriberIdentifier) => {
        this._addTmpSubScriberRelation(
          {
            name: subscriberIdentifier,
            client: subscriber
          },
          { name: publisher.name, ip: publisher.ip }
        );
        fileLog(
          // eslint-disable-next-line max-len
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removing , subscriber: ${subscriberIdentifier} will be add  tmpSubScriberRelation`,
          "Broker",
          "info"
        );
      });
      this._publisherMap.delete(identifier);
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removed `,
        "Broker",
        "info"
      );
      if (!this.hasPublishers) {
        fileLog(
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: _publisherMap is empty, all server will exit `,
          "Broker",
          "warn"
        );
        this.exit();
      }
    } catch (err) {
      const msg = error(err, "EXIT_PUBLISHER" /* EXIT_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _addWebClient(context, client) {
    const { name } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    if (this._webClientMap.has(identifier)) {
      fileLog(
        `${identifier}} has been added, this action will override prev WebClient`,
        "Broker",
        "warn"
      );
    }
    try {
      this._webClientMap.set(identifier, client);
      fileLog(`${identifier} adding WebClient Succeed`, "Broker", "info");
    } catch (err) {
      const msg = error(err, "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _notifyWebClient(context, client) {
    const { name, updateMode } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    const webClient = this._webClientMap.get(identifier);
    if (!webClient) {
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] ${identifier} has not been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const api = new ReloadWebClientAPI({ name, updateMode });
      webClient.send(JSON.stringify(api));
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] Notify ${name} WebClient Succeed`,
        "Broker",
        "info"
      );
    } catch (err) {
      const msg = error(err, "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  // app1 consumes provider1, and provider1 not launch. this._tmpSubscriberShelter at this time: {provider1: Map{subscribers: Map{app1: app1+ip+client'}, timestamp: 'xx'} }
  _addTmpSubScriberRelation(subscriber, publisher) {
    const publisherIdentifier = getIdentifier({
      name: publisher.name,
      ip: publisher.ip
    });
    const subscriberIdentifier = subscriber.name;
    const shelter = this._tmpSubscriberShelter.get(publisherIdentifier);
    if (!shelter) {
      const map = /* @__PURE__ */ new Map();
      map.set(subscriberIdentifier, subscriber);
      this._tmpSubscriberShelter.set(publisherIdentifier, {
        subscribers: map,
        timestamp: Date.now()
      });
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier}'s subscriber has ${subscriberIdentifier} `,
        "Broker",
        "info"
      );
      return;
    }
    const tmpSubScriberShelterSubscriber = shelter.subscribers.get(subscriberIdentifier);
    if (tmpSubScriberShelterSubscriber) {
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier} and ${subscriberIdentifier} relation has been added`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
      shelter.timestamp = Date.now();
    } else {
      fileLog(
        // eslint-disable-next-line max-len
        `AddTmpSubscriberLog ${publisherIdentifier}'s shelter has been added, update shelter.subscribers ${subscriberIdentifier}`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
    }
  }
  _getTmpSubScribers(publisherIdentifier) {
    var _a;
    return (_a = this._tmpSubscriberShelter.get(publisherIdentifier)) == null ? void 0 : _a.subscribers;
  }
  // after adding publisher, it will change the temp subscriber to regular subscriber
  _consumeTmpSubScribers(publisher, tmpSubScribers) {
    tmpSubScribers.forEach((tmpSubScriber, identifier) => {
      fileLog(
        `notifyTmpSubScribers ${publisher.name} will be add a subscriber: ${identifier} `,
        "Broker",
        "warn"
      );
      publisher.addSubscriber(identifier, tmpSubScriber.client);
      publisher.notifySubscriber(identifier, {
        updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
        updateMode: "PASSIVE" /* PASSIVE */,
        updateSourcePaths: [publisher.name],
        remoteTypeTarPath: publisher.remoteTypeTarPath,
        name: publisher.name
      });
    });
  }
  _clearTmpSubScriberRelation(identifier) {
    this._tmpSubscriberShelter.delete(identifier);
  }
  _clearTmpSubScriberRelations() {
    this._tmpSubscriberShelter.clear();
  }
  _disconnect() {
    this._publisherMap.forEach((publisher) => {
      publisher.close();
    });
  }
  // Every day on 0/6/9/12/15//18, Publishers that have not been connected within 1.5 hours will be cleared regularly.
  // If process.env.FEDERATION_SERVER_TEST is set, it will be read at a specified time.
  _setSchedule() {
    const rule = new import_node_schedule.default.RecurrenceRule();
    if (Number(process.env["FEDERATION_SERVER_TEST"])) {
      const interval = Number(process.env["FEDERATION_SERVER_TEST"]) / 1e3;
      const second = [];
      for (let i = 0; i < 60; i = i + interval) {
        second.push(i);
      }
      rule.second = second;
    } else {
      rule.second = 0;
      rule.hour = [0, 3, 6, 9, 12, 15, 18];
      rule.minute = 0;
    }
    const serverTest = Number(process.env["FEDERATION_SERVER_TEST"]);
    this._scheduleJob = import_node_schedule.default.scheduleJob(rule, () => {
      this._tmpSubscriberShelter.forEach((tmpSubscriber, identifier) => {
        fileLog(
          ` _clearTmpSubScriberRelation ${identifier},  ${Date.now() - tmpSubscriber.timestamp >= (process.env["GARFISH_MODULE_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)}`,
          "Broker",
          "info"
        );
        if (Date.now() - tmpSubscriber.timestamp >= (process.env["FEDERATION_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)) {
          this._clearTmpSubScriberRelation(identifier);
        }
      });
    });
  }
  _clearSchedule() {
    if (!this._scheduleJob) {
      return;
    }
    this._scheduleJob.cancel();
    this._scheduleJob = null;
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      this.exit();
    });
    process.on("SIGINT", () => {
      this.exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
    process.on("uncaughtException", (error2) => {
      console.error("Unhandled Exception Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
  }
  async start() {
  }
  exit() {
    const brokerExitLog = new BrokerExitLog();
    this.broadcast(JSON.stringify(brokerExitLog));
    this._disconnect();
    this._clearSchedule();
    this._clearTmpSubScriberRelations();
    this._webSocketServer && this._webSocketServer.close();
    this._secureWebSocketServer && this._secureWebSocketServer.close();
    process.exit(0);
  }
  broadcast(message) {
    var _a, _b;
    fileLog(
      `[broadcast] exit info : ${JSON.stringify(message)}`,
      "Broker",
      "warn"
    );
    (_a = this._webSocketServer) == null ? void 0 : _a.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
    (_b = this._secureWebSocketServer) == null ? void 0 : _b.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
  }
};
_Broker.WEB_SOCKET_CONNECT_MAGIC_ID = WEB_SOCKET_CONNECT_MAGIC_ID;
_Broker.DEFAULT_WEB_SOCKET_PORT = DEFAULT_WEB_SOCKET_PORT;
_Broker.DEFAULT_SECURE_WEB_SOCKET_PORT = 16324;
_Broker.DEFAULT_WAITING_TIME = 1.5 * 60 * 60 * 1e3;
var Broker = _Broker;

// packages/dts-plugin/src/server/createKoaServer.ts
var import_fs_extra = __toESM(require("fs-extra"));
var import_koa = __toESM(require("koa"));

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var retrieveTypesZipPath = (mfTypesPath, remoteOptions) => (0, import_path2.join)(
  mfTypesPath.replace(remoteOptions.typesFolder, ""),
  `${remoteOptions.typesFolder}.zip`
);
var createTypesArchive = async (tsConfig, remoteOptions) => {
  const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
  const zip = new import_adm_zip.default();
  zip.addLocalFolder(mfTypesPath);
  return zip.writeZipPromise(retrieveTypesZipPath(mfTypesPath, remoteOptions));
};
var downloadErrorLogger = (destinationFolder, fileToDownload) => (reason) => {
  throw {
    ...reason,
    message: `Network error: Unable to download federated mocks for '${destinationFolder}' from '${fileToDownload}' because '${reason.message}'`
  };
};
var retrieveTypesArchiveDestinationPath = (hostOptions, destinationFolder) => {
  return (0, import_path2.resolve)(
    hostOptions.context,
    hostOptions.typesFolder,
    destinationFolder
  );
};
var downloadTypesArchive = (hostOptions) => {
  let retries = 0;
  return async ([destinationFolder, fileToDownload]) => {
    const destinationPath = retrieveTypesArchiveDestinationPath(
      hostOptions,
      destinationFolder
    );
    while (retries++ < hostOptions.maxRetries) {
      try {
        const url = fileToDownload;
        const response = await import_axios.default.get(url, { responseType: "arraybuffer" }).catch(downloadErrorLogger(destinationFolder, url));
        const zip = new import_adm_zip.default(Buffer.from(response.data));
        zip.extractAllTo(destinationPath, true);
        return [destinationFolder, destinationPath];
      } catch (error2) {
        fileLog(
          `Error during types archive download: ${(error2 == null ? void 0 : error2.message) || "unknown error"}`,
          "downloadTypesArchive",
          "error"
        );
        if (retries >= hostOptions.maxRetries) {
          if (hostOptions.abortOnError !== false) {
            throw error2;
          }
          return void 0;
        }
      }
    }
  };
};

// packages/dts-plugin/src/core/configurations/hostPlugin.ts
var import_sdk3 = require("@module-federation/sdk");
var import_managers = require("@module-federation/managers");
var defaultOptions = {
  typesFolder: "@mf-types",
  remoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  maxRetries: 3,
  implementation: "",
  context: process.cwd(),
  abortOnError: true,
  consumeAPITypes: false
};
var buildZipUrl = (hostOptions, url) => {
  const remoteUrl = new URL(url);
  const pathnameWithoutEntry = remoteUrl.pathname.split("/").slice(0, -1).join("/");
  remoteUrl.pathname = `${pathnameWithoutEntry}/${hostOptions.remoteTypesFolder}.zip`;
  return remoteUrl.href;
};
var buildApiTypeUrl = (zipUrl) => {
  if (!zipUrl) {
    return void 0;
  }
  return zipUrl.replace(".zip", ".d.ts");
};
var retrieveRemoteInfo = (options) => {
  const { hostOptions, remoteAlias, remote } = options;
  const parsedInfo = (0, import_sdk3.parseEntry)(remote, void 0, "@");
  const url = "entry" in parsedInfo ? parsedInfo.entry : parsedInfo.name === remote ? remote : "";
  const zipUrl = url ? buildZipUrl(hostOptions, url) : "";
  return {
    name: parsedInfo.name || remoteAlias,
    url,
    zipUrl,
    apiTypeUrl: buildApiTypeUrl(zipUrl),
    alias: remoteAlias
  };
};
var resolveRemotes = (hostOptions) => {
  const parsedOptions = import_managers.utils.parseOptions(
    hostOptions.moduleFederationConfig.remotes || {},
    (item, key) => ({
      remote: Array.isArray(item) ? item[0] : item,
      key
    }),
    (item, key) => ({
      remote: Array.isArray(item.external) ? item.external[0] : item.external,
      key
    })
  );
  return parsedOptions.reduce(
    (accumulator, item) => {
      const { key, remote } = item[1];
      accumulator[key] = retrieveRemoteInfo({
        hostOptions,
        remoteAlias: key,
        remote
      });
      return accumulator;
    },
    {}
  );
};
var retrieveHostConfig = (options) => {
  validateOptions(options);
  const hostOptions = { ...defaultOptions, ...options };
  const mapRemotesToDownload = resolveRemotes(hostOptions);
  return {
    hostOptions,
    mapRemotesToDownload
  };
};

// packages/dts-plugin/src/core/constant.ts
var REMOTE_ALIAS_IDENTIFIER = "REMOTE_ALIAS_IDENTIFIER";
var REMOTE_API_TYPES_FILE_NAME = "apis.d.ts";
var HOST_API_TYPES_FILE_NAME = "index.d.ts";

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_axios2 = __toESM(require("axios"));
var DTSManager = class {
  constructor(options) {
    this.options = (0, import_lodash.default)(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.runtimePkgs = [
      "@module-federation/runtime",
      "@module-federation/enhanced/runtime",
      "@module-federation/runtime-tools"
    ];
    this.loadedRemoteAPIAlias = [];
    this.remoteAliasMap = {};
    this.extraOptions = (options == null ? void 0 : options.extraOptions) || {};
  }
  generateAPITypes(mapComponentsToExpose) {
    const exposePaths = /* @__PURE__ */ new Set();
    const packageType = Object.keys(mapComponentsToExpose).reduce(
      (sum, exposeKey) => {
        const exposePath = import_path3.default.join(REMOTE_ALIAS_IDENTIFIER, exposeKey).split(import_path3.default.sep).join("/");
        exposePaths.add(`'${exposePath}'`);
        const curType = `T extends '${exposePath}' ? typeof import('${exposePath}') :`;
        sum = curType + sum;
        return sum;
      },
      "any;"
    );
    const exposePathKeys = [...exposePaths].join(" | ");
    return `
    export type RemoteKeys = ${exposePathKeys};
    type PackageType<T> = ${packageType}`;
  }
  async extractRemoteTypes(options) {
    const { remoteOptions, tsConfig } = options;
    if (!remoteOptions.extractRemoteTypes) {
      return;
    }
    let hasRemotes = false;
    const remotes = remoteOptions.moduleFederationConfig.remotes;
    if (remotes) {
      if (Array.isArray(remotes)) {
        hasRemotes = Boolean(remotes.length);
      } else if (typeof remotes === "object") {
        hasRemotes = Boolean(Object.keys(remotes).length);
      }
    }
    const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
    if (hasRemotes) {
      const tempHostOptions = {
        moduleFederationConfig: remoteOptions.moduleFederationConfig,
        typesFolder: import_path3.default.join(mfTypesPath, "node_modules"),
        remoteTypesFolder: (remoteOptions == null ? void 0 : remoteOptions.hostRemoteTypesFolder) || remoteOptions.typesFolder,
        deleteTypesFolder: true,
        context: remoteOptions.context,
        implementation: remoteOptions.implementation,
        abortOnError: false
      };
      await this.consumeArchiveTypes(tempHostOptions);
    }
  }
  async generateTypes() {
    var _a;
    try {
      const { options } = this;
      if (!options.remote) {
        throw new Error(
          "options.remote is required if you want to generateTypes"
        );
      }
      const { remoteOptions, tsConfig, mapComponentsToExpose } = retrieveRemoteConfig(options.remote);
      if (!Object.keys(mapComponentsToExpose).length) {
        return;
      }
      this.extractRemoteTypes({
        remoteOptions,
        tsConfig,
        mapComponentsToExpose
      });
      compileTs(mapComponentsToExpose, tsConfig, remoteOptions);
      await createTypesArchive(tsConfig, remoteOptions);
      let apiTypesPath = "";
      if (remoteOptions.generateAPITypes) {
        const apiTypes = this.generateAPITypes(mapComponentsToExpose);
        apiTypesPath = retrieveMfAPITypesPath(tsConfig, remoteOptions);
        import_fs.default.writeFileSync(apiTypesPath, apiTypes);
      }
      if (remoteOptions.deleteTypesFolder) {
        await (0, import_promises.rm)(retrieveMfTypesPath(tsConfig, remoteOptions), {
          recursive: true,
          force: true
        });
      }
      console.log(import_ansi_colors2.default.green("Federated types created correctly"));
    } catch (error2) {
      if (((_a = this.options.remote) == null ? void 0 : _a.abortOnError) === false) {
        console.error(
          import_ansi_colors2.default.red(`Unable to compile federated types, ${error2}`)
        );
      } else {
        throw error2;
      }
    }
  }
  async requestRemoteManifest(remoteInfo) {
    try {
      if (!remoteInfo.url.includes(import_sdk4.MANIFEST_EXT)) {
        return remoteInfo;
      }
      const url = remoteInfo.url;
      const res = await (0, import_axios2.default)({
        method: "get",
        url
      });
      const manifestJson = res.data;
      if (!manifestJson.metaData.types.zip) {
        throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
      }
      const addProtocol = (u) => {
        if (u.startsWith("//")) {
          return `https:${u}`;
        }
        return u;
      };
      let publicPath = "publicPath" in manifestJson.metaData ? manifestJson.metaData.publicPath : new Function(manifestJson.metaData.getPublicPath)();
      if (publicPath === "auto") {
        publicPath = (0, import_sdk4.inferAutoPublicPath)(remoteInfo.url);
      }
      remoteInfo.zipUrl = new URL(
        import_path3.default.join(addProtocol(publicPath), manifestJson.metaData.types.zip)
      ).href;
      if (!manifestJson.metaData.types.api) {
        console.warn(`Can not get ${remoteInfo.name}'s api types url!`);
        remoteInfo.apiTypeUrl = "";
        return remoteInfo;
      }
      remoteInfo.apiTypeUrl = new URL(
        import_path3.default.join(addProtocol(publicPath), manifestJson.metaData.types.api)
      ).href;
      return remoteInfo;
    } catch (_err) {
      fileLog(
        `fetch manifest failed, ${_err}, ${remoteInfo.name} will be ignored`,
        "requestRemoteManifest",
        "error"
      );
      return remoteInfo;
    }
  }
  async consumeTargetRemotes(hostOptions, remoteInfo) {
    if (!remoteInfo.zipUrl) {
      throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
    }
    const typesDownloader = downloadTypesArchive(hostOptions);
    return typesDownloader([remoteInfo.alias, remoteInfo.zipUrl]);
  }
  async downloadAPITypes(remoteInfo, destinationPath) {
    const { apiTypeUrl } = remoteInfo;
    if (!apiTypeUrl) {
      return;
    }
    try {
      const url = apiTypeUrl;
      const res = await import_axios2.default.get(url);
      let apiTypeFile = res.data;
      apiTypeFile = apiTypeFile.replaceAll(
        REMOTE_ALIAS_IDENTIFIER,
        remoteInfo.alias
      );
      const filePath = import_path3.default.join(destinationPath, REMOTE_API_TYPES_FILE_NAME);
      import_fs.default.writeFileSync(filePath, apiTypeFile);
      this.loadedRemoteAPIAlias.push(remoteInfo.alias);
    } catch (err) {
      fileLog(
        `Unable to download "${remoteInfo.name}" api types, ${err}`,
        "consumeTargetRemotes",
        "error"
      );
    }
  }
  consumeAPITypes(hostOptions) {
    if (!this.loadedRemoteAPIAlias.length) {
      return;
    }
    const packageTypes = [];
    const remoteKeys = [];
    const importTypeStr = this.loadedRemoteAPIAlias.sort().map((alias, index) => {
      const remoteKey = `RemoteKeys_${index}`;
      const packageType = `PackageType_${index}`;
      packageTypes.push(`T extends ${remoteKey} ? ${packageType}<T>`);
      remoteKeys.push(remoteKey);
      return `import type { PackageType as ${packageType},RemoteKeys as ${remoteKey} } from './${alias}/apis.d.ts';`;
    }).join("\n");
    const remoteKeysStr = `type RemoteKeys = ${remoteKeys.join(" | ")};`;
    const packageTypesStr = `type PackageType<T, Y=any> = ${[
      ...packageTypes,
      "Y"
    ].join(" :\n")} ;`;
    const pkgsDeclareStr = this.runtimePkgs.map((pkg) => {
      return `declare module "${pkg}" {
      ${remoteKeysStr}
      ${packageTypesStr}
      export function loadRemote<T extends RemoteKeys,Y>(packageName: T): Promise<PackageType<T, Y>>;
      export function loadRemote<T extends string,Y>(packageName: T): Promise<PackageType<T, Y>>;
    }`;
    }).join("\n");
    const fileStr = `${importTypeStr}
    ${pkgsDeclareStr}
    `;
    import_fs.default.writeFileSync(
      import_path3.default.join(
        hostOptions.context,
        hostOptions.typesFolder,
        HOST_API_TYPES_FILE_NAME
      ),
      fileStr
    );
  }
  async consumeArchiveTypes(options) {
    const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(options);
    if (hostOptions.deleteTypesFolder) {
      await (0, import_promises.rm)(hostOptions.typesFolder, {
        recursive: true,
        force: true
      }).catch(
        (error2) => fileLog(
          `Unable to remove types folder, ${error2}`,
          "consumeArchiveTypes",
          "error"
        )
      );
    }
    const downloadPromises = Object.entries(mapRemotesToDownload).map(
      async (item) => {
        const remoteInfo = item[1];
        if (!this.remoteAliasMap[remoteInfo.alias]) {
          const requiredRemoteInfo = await this.requestRemoteManifest(remoteInfo);
          this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
        }
        return this.consumeTargetRemotes(
          hostOptions,
          this.remoteAliasMap[remoteInfo.alias]
        );
      }
    );
    const downloadPromisesResult = await Promise.allSettled(downloadPromises);
    return {
      hostOptions,
      downloadPromisesResult
    };
  }
  async consumeTypes() {
    var _a;
    try {
      const { options } = this;
      if (!options.host) {
        throw new Error("options.host is required if you want to consumeTypes");
      }
      const { mapRemotesToDownload } = retrieveHostConfig(options.host);
      if (!Object.keys(mapRemotesToDownload).length) {
        return;
      }
      const { downloadPromisesResult, hostOptions } = await this.consumeArchiveTypes(options.host);
      if (hostOptions.consumeAPITypes) {
        await Promise.all(
          downloadPromisesResult.map(async (item) => {
            if (item.status === "rejected" || !item.value) {
              return;
            }
            const [alias, destinationPath] = item.value;
            const remoteInfo = this.remoteAliasMap[alias];
            if (!remoteInfo) {
              return;
            }
            await this.downloadAPITypes(remoteInfo, destinationPath);
          })
        );
        this.consumeAPITypes(hostOptions);
      }
      console.log(import_ansi_colors2.default.green("Federated types extraction completed"));
    } catch (err) {
      if (((_a = this.options.host) == null ? void 0 : _a.abortOnError) === false) {
        fileLog(
          `Unable to consume federated types, ${err}`,
          "consumeTypes",
          "error"
        );
      } else {
        throw err;
      }
    }
  }
  async updateTypes(options) {
    var _a, _b, _c;
    const { remoteName, updateMode } = options;
    const hostName = (_c = (_b = (_a = this.options) == null ? void 0 : _a.host) == null ? void 0 : _b.moduleFederationConfig) == null ? void 0 : _c.name;
    if (updateMode === "POSITIVE" /* POSITIVE */ && remoteName === hostName) {
      if (!this.options.remote) {
        return;
      }
      this.generateTypes();
    } else {
      const { remoteAliasMap } = this;
      if (!this.options.host) {
        return;
      }
      const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(
        this.options.host
      );
      const loadedRemoteInfo = Object.values(remoteAliasMap).find(
        (i) => i.name === remoteName
      );
      if (!loadedRemoteInfo) {
        const remoteInfo = Object.values(mapRemotesToDownload).find((item) => {
          return item.name === remoteName;
        });
        if (remoteInfo) {
          if (!this.remoteAliasMap[remoteInfo.alias]) {
            const requiredRemoteInfo = await this.requestRemoteManifest(remoteInfo);
            this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
          }
          await this.consumeTargetRemotes(
            hostOptions,
            this.remoteAliasMap[remoteInfo.alias]
          );
        }
      } else {
        await this.consumeTargetRemotes(hostOptions, loadedRemoteInfo);
      }
    }
  }
};

// packages/dts-plugin/src/core/lib/utils.ts
var import_fs2 = __toESM(require("fs"));
var import_ansi_colors3 = __toESM(require("ansi-colors"));
function getDTSManagerConstructor(implementation) {
  if (implementation) {
    const NewConstructor = require(implementation);
    return NewConstructor.default ? NewConstructor.default : NewConstructor;
  }
  return DTSManager;
}
var validateOptions = (options) => {
  if (!options.moduleFederationConfig) {
    throw new Error("moduleFederationConfig is required");
  }
};
function retrieveTypesAssetsInfo(options) {
  let apiTypesPath = "";
  let zipTypesPath = "";
  try {
    const { tsConfig, remoteOptions, mapComponentsToExpose } = retrieveRemoteConfig(options);
    if (!Object.keys(mapComponentsToExpose).length) {
      return {
        apiTypesPath,
        zipTypesPath,
        zipName: "",
        apiFileName: ""
      };
    }
    const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
    zipTypesPath = retrieveTypesZipPath(mfTypesPath, remoteOptions);
    if (remoteOptions.generateAPITypes) {
      apiTypesPath = retrieveMfAPITypesPath(tsConfig, remoteOptions);
    }
    return {
      apiTypesPath,
      zipTypesPath,
      zipName: import_path4.default.basename(zipTypesPath),
      apiFileName: import_path4.default.basename(apiTypesPath)
    };
  } catch (err) {
    console.error(import_ansi_colors3.default.red(`Unable to compile federated types, ${err}`));
    return {
      apiTypesPath: "",
      zipTypesPath: "",
      zipName: "",
      apiFileName: ""
    };
  }
}
var isTSProject = (dtsOptions, context = process.cwd()) => {
  if (dtsOptions === false) {
    return false;
  }
  try {
    let filepath = "";
    if (typeof dtsOptions === "object" && dtsOptions.tsConfigPath) {
      filepath = dtsOptions.tsConfigPath;
    } else {
      filepath = import_path4.default.resolve(context, "./tsconfig.json");
    }
    if (!import_path4.default.isAbsolute(filepath)) {
      filepath = import_path4.default.resolve(context, filepath);
    }
    return import_fs2.default.existsSync(filepath);
  } catch (err) {
    return false;
  }
};

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var defaultOptions2 = {
  tsConfigPath: "./tsconfig.json",
  typesFolder: "@mf-types",
  compiledTypesFolder: "compiled-types",
  hostRemoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  additionalFilesToCompile: [],
  compilerInstance: "tsc",
  compileInChildProcess: false,
  implementation: "",
  generateAPITypes: false,
  context: process.cwd(),
  abortOnError: true,
  extractRemoteTypes: false,
  extractThirdParty: false
};
var readTsConfig = ({
  tsConfigPath,
  typesFolder,
  compiledTypesFolder,
  context
}) => {
  const resolvedTsConfigPath = (0, import_path5.resolve)(context, tsConfigPath);
  const readResult = import_typescript2.default.readConfigFile(
    resolvedTsConfigPath,
    import_typescript2.default.sys.readFile
  );
  if (readResult.error) {
    throw new Error(readResult.error.messageText.toString());
  }
  const configContent = import_typescript2.default.parseJsonConfigFileContent(
    readResult.config,
    import_typescript2.default.sys,
    (0, import_path5.dirname)(resolvedTsConfigPath)
  );
  const outDir = (0, import_path5.resolve)(
    context,
    configContent.options.outDir || "dist",
    typesFolder,
    compiledTypesFolder
  );
  return {
    ...configContent.options,
    emitDeclarationOnly: true,
    noEmit: false,
    declaration: true,
    outDir
  };
};
var TS_EXTENSIONS = ["ts", "tsx", "vue", "svelte"];
var resolveWithExtension = (exposedPath, context) => {
  if ((0, import_path5.extname)(exposedPath)) {
    return (0, import_path5.resolve)(context, exposedPath);
  }
  for (const extension of TS_EXTENSIONS) {
    const exposedPathWithExtension = (0, import_path5.resolve)(
      context,
      `${exposedPath}.${extension}`
    );
    if ((0, import_fs3.existsSync)(exposedPathWithExtension)) {
      return exposedPathWithExtension;
    }
  }
  return void 0;
};
var resolveExposes = (remoteOptions) => {
  const parsedOptions = import_managers2.utils.parseOptions(
    remoteOptions.moduleFederationConfig.exposes || {},
    (item, key) => ({
      exposePath: Array.isArray(item) ? item[0] : item,
      key
    }),
    (item, key) => ({
      exposePath: Array.isArray(item.import) ? item.import[0] : item.import[0],
      key
    })
  );
  return parsedOptions.reduce(
    (accumulator, item) => {
      const { exposePath, key } = item[1];
      accumulator[key] = resolveWithExtension(exposePath, remoteOptions.context) || resolveWithExtension(
        (0, import_path5.join)(exposePath, "index"),
        remoteOptions.context
      ) || exposePath;
      return accumulator;
    },
    {}
  );
};
var retrieveRemoteConfig = (options) => {
  validateOptions(options);
  const remoteOptions = {
    ...defaultOptions2,
    ...options
  };
  const mapComponentsToExpose = resolveExposes(remoteOptions);
  const tsConfig = readTsConfig(remoteOptions);
  return {
    tsConfig,
    mapComponentsToExpose,
    remoteOptions
  };
};

// packages/dts-plugin/src/core/lib/generateTypes.ts
async function generateTypes(options) {
  var _a;
  const DTSManagerConstructor = getDTSManagerConstructor(
    (_a = options.remote) == null ? void 0 : _a.implementation
  );
  const dtsManager = new DTSManagerConstructor(options);
  return dtsManager.generateTypes();
}

// packages/dts-plugin/src/core/lib/DtsWorker.ts
var import_path6 = __toESM(require("path"));
var import_lodash2 = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/rpc/index.ts
var rpc_exports = {};
__export(rpc_exports, {
  RpcExitError: () => RpcExitError,
  RpcGMCallTypes: () => RpcGMCallTypes,
  createRpcWorker: () => createRpcWorker,
  exposeRpc: () => exposeRpc,
  getRpcWorkerData: () => getRpcWorkerData,
  wrapRpc: () => wrapRpc
});

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
var import_process = __toESM(require("process"));

// packages/dts-plugin/src/core/rpc/types.ts
var RpcGMCallTypes = /* @__PURE__ */ ((RpcGMCallTypes2) => {
  RpcGMCallTypes2["CALL"] = "mf_call";
  RpcGMCallTypes2["RESOLVE"] = "mf_resolve";
  RpcGMCallTypes2["REJECT"] = "mf_reject";
  RpcGMCallTypes2["EXIT"] = "mf_exit";
  return RpcGMCallTypes2;
})(RpcGMCallTypes || {});

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
function exposeRpc(fn) {
  const sendMessage = (message) => new Promise((resolve5, reject) => {
    if (!import_process.default.send) {
      reject(new Error(`Process ${import_process.default.pid} doesn't have IPC channels`));
    } else if (!import_process.default.connected) {
      reject(
        new Error(`Process ${import_process.default.pid} doesn't have open IPC channels`)
      );
    } else {
      import_process.default.send(message, void 0, void 0, (error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve5(void 0);
        }
      });
    }
  });
  const handleMessage = async (message) => {
    if (message.type === "mf_call" /* CALL */) {
      if (!import_process.default.send) {
        return;
      }
      let value, error2;
      try {
        value = await fn(...message.args);
      } catch (fnError) {
        error2 = fnError;
      }
      try {
        if (error2) {
          await sendMessage({
            type: "mf_reject" /* REJECT */,
            id: message.id,
            error: error2
          });
        } else {
          await sendMessage({
            type: "mf_resolve" /* RESOLVE */,
            id: message.id,
            value
          });
        }
      } catch (sendError) {
        if (error2) {
          if (error2 instanceof Error) {
            console.error(error2);
          }
        }
        console.error(sendError);
      }
    }
  };
  import_process.default.on("message", handleMessage);
}

// packages/dts-plugin/src/core/rpc/rpc-error.ts
var RpcExitError = class extends Error {
  constructor(message, code, signal) {
    super(message);
    this.code = code;
    this.signal = signal;
    this.name = "RpcExitError";
  }
};

// packages/dts-plugin/src/core/rpc/wrap-rpc.ts
function createControlledPromise() {
  let resolve5 = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((aResolve, aReject) => {
    resolve5 = aResolve;
    reject = aReject;
  });
  return {
    promise,
    resolve: resolve5,
    reject
  };
}
function wrapRpc(childProcess, options) {
  return async (...args) => {
    if (!childProcess.send) {
      throw new Error(`Process ${childProcess.pid} doesn't have IPC channels`);
    } else if (!childProcess.connected) {
      throw new Error(
        `Process ${childProcess.pid} doesn't have open IPC channels`
      );
    }
    const { id, once } = options;
    const {
      promise: resultPromise,
      resolve: resolveResult,
      reject: rejectResult
    } = createControlledPromise();
    const {
      promise: sendPromise,
      resolve: resolveSend,
      reject: rejectSend
    } = createControlledPromise();
    const handleMessage = (message) => {
      if ((message == null ? void 0 : message.id) === id) {
        if (message.type === "mf_resolve" /* RESOLVE */) {
          resolveResult(message.value);
        } else if (message.type === "mf_reject" /* REJECT */) {
          rejectResult(message.error);
        }
      }
      if (once && (childProcess == null ? void 0 : childProcess.kill)) {
        childProcess.kill("SIGTERM");
      }
    };
    const handleClose = (code, signal) => {
      rejectResult(
        new RpcExitError(
          code ? `Process ${childProcess.pid} exited with code ${code}${signal ? ` [${signal}]` : ""}` : `Process ${childProcess.pid} exited${signal ? ` [${signal}]` : ""}`,
          code,
          signal
        )
      );
      removeHandlers();
    };
    const removeHandlers = () => {
      childProcess.off("message", handleMessage);
      childProcess.off("close", handleClose);
    };
    if (once) {
      childProcess.once("message", handleMessage);
    } else {
      childProcess.on("message", handleMessage);
    }
    childProcess.on("close", handleClose);
    childProcess.send(
      {
        type: "mf_call" /* CALL */,
        id,
        args
      },
      (error2) => {
        if (error2) {
          rejectSend(error2);
          removeHandlers();
        } else {
          resolveSend(void 0);
        }
      }
    );
    return sendPromise.then(() => resultPromise);
  };
}

// packages/dts-plugin/src/core/rpc/rpc-worker.ts
var child_process = __toESM(require("child_process"));
var process3 = __toESM(require("process"));
var import_crypto = require("crypto");
var FEDERATION_WORKER_DATA_ENV_KEY = "VMOK_WORKER_DATA_ENV";
function createRpcWorker(modulePath, data, memoryLimit, once) {
  const options = {
    env: {
      ...process3.env,
      [FEDERATION_WORKER_DATA_ENV_KEY]: JSON.stringify(data || {})
    },
    stdio: ["inherit", "inherit", "inherit", "ipc"],
    serialization: "advanced"
  };
  if (memoryLimit) {
    options.execArgv = [`--max-old-space-size=${memoryLimit}`];
  }
  let childProcess, remoteMethod;
  const id = (0, import_crypto.randomUUID)();
  const worker = {
    connect(...args) {
      if (childProcess && !childProcess.connected) {
        childProcess.send({
          type: "mf_exit" /* EXIT */,
          id
        });
        childProcess = void 0;
        remoteMethod = void 0;
      }
      if (!(childProcess == null ? void 0 : childProcess.connected)) {
        childProcess = child_process.fork(modulePath, options);
        remoteMethod = wrapRpc(childProcess, { id, once });
      }
      if (!remoteMethod) {
        return Promise.reject(
          new Error("Worker is not connected - cannot perform RPC.")
        );
      }
      return remoteMethod(...args);
    },
    terminate() {
      var _a;
      (_a = childProcess == null ? void 0 : childProcess.send) == null ? void 0 : _a.call(childProcess, {
        type: "mf_exit" /* EXIT */,
        id
      });
      childProcess = void 0;
      remoteMethod = void 0;
    },
    get connected() {
      return Boolean(childProcess == null ? void 0 : childProcess.connected);
    },
    get process() {
      return childProcess;
    },
    get id() {
      return id;
    }
  };
  return worker;
}
function getRpcWorkerData() {
  return JSON.parse(process3.env[FEDERATION_WORKER_DATA_ENV_KEY] || "{}");
}

// packages/dts-plugin/src/core/lib/DtsWorker.ts
var DtsWorker = class {
  constructor(options) {
    this._options = (0, import_lodash2.default)(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.removeUnSerializationOptions();
    this.rpcWorker = createRpcWorker(
      import_path6.default.resolve(__dirname, "./forkGenerateDts.js"),
      {},
      void 0,
      true
    );
    this._res = this.rpcWorker.connect(this._options);
  }
  removeUnSerializationOptions() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((_b = (_a = this._options.remote) == null ? void 0 : _a.moduleFederationConfig) == null ? void 0 : _b.manifest) {
      (_d = (_c = this._options.remote) == null ? void 0 : _c.moduleFederationConfig) == null ? true : delete _d.manifest;
    }
    if ((_f = (_e = this._options.host) == null ? void 0 : _e.moduleFederationConfig) == null ? void 0 : _f.manifest) {
      (_h = (_g = this._options.host) == null ? void 0 : _g.moduleFederationConfig) == null ? true : delete _h.manifest;
    }
  }
  get controlledPromise() {
    return Promise.resolve(this._res).then(() => {
      this.exit();
    });
  }
  exit() {
    var _a;
    (_a = this.rpcWorker) == null ? void 0 : _a.terminate();
  }
};

// packages/dts-plugin/src/core/lib/generateTypesInChildProcess.ts
async function generateTypesInChildProcess(options) {
  const dtsWorker = new DtsWorker(options);
  return dtsWorker.controlledPromise;
}

// packages/dts-plugin/src/core/lib/consumeTypes.ts
async function consumeTypes(options) {
  var _a;
  const DTSManagerConstructor = getDTSManagerConstructor(
    (_a = options.host) == null ? void 0 : _a.implementation
  );
  const dtsManager = new DTSManagerConstructor(options);
  await dtsManager.consumeTypes();
}

// packages/dts-plugin/src/dev-worker/DevWorker.ts
var DevWorker = class {
  constructor(options) {
    this._options = (0, import_lodash3.default)(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.removeUnSerializationOptions();
    this._rpcWorker = rpc_exports.createRpcWorker(
      import_path7.default.resolve(__dirname, "./forkDevWorker.js"),
      {},
      void 0,
      false
    );
    this._res = this._rpcWorker.connect(this._options);
  }
  // moduleFederationConfig.manifest may have un serialization options
  removeUnSerializationOptions() {
    var _a, _b, _c, _d;
    (_b = (_a = this._options.host) == null ? void 0 : _a.moduleFederationConfig) == null ? true : delete _b.manifest;
    (_d = (_c = this._options.remote) == null ? void 0 : _c.moduleFederationConfig) == null ? true : delete _d.manifest;
  }
  get controlledPromise() {
    return this._res;
  }
  update() {
    var _a, _b;
    (_b = (_a = this._rpcWorker.process) == null ? void 0 : _a.send) == null ? void 0 : _b.call(_a, {
      type: rpc_exports.RpcGMCallTypes.CALL,
      id: this._rpcWorker.id,
      args: [void 0, "update"]
    });
  }
  exit() {
    var _a;
    (_a = this._rpcWorker) == null ? void 0 : _a.terminate();
  }
};

// packages/dts-plugin/src/dev-worker/createDevWorker.ts
async function removeLogFile() {
  try {
    const logDir = path5.resolve(process.cwd(), ".mf/typesGenerate.log");
    await fse.remove(logDir);
  } catch (err) {
    console.error("removeLogFile error", "forkDevWorker", err);
  }
}
function createDevWorker(options) {
  removeLogFile();
  return new DevWorker({ ...options });
}

// packages/dts-plugin/src/plugins/DevPlugin.ts
var import_sdk5 = require("@module-federation/sdk");
var import_path8 = __toESM(require("path"));

// packages/dts-plugin/src/plugins/utils.ts
function isDev() {
  return process.env["NODE_ENV"] === "development";
}

// packages/dts-plugin/src/plugins/DevPlugin.ts
function ensureTempDir(filePath) {
  try {
    const dir = import_path8.default.dirname(filePath);
    import_fs_extra2.default.ensureDirSync(dir);
  } catch (_err) {
  }
}
var DevPlugin = class _DevPlugin {
  constructor(options) {
    this.name = "MFDevPlugin";
    this._options = options;
  }
  static ensureLiveReloadEntry(options, filePath) {
    ensureTempDir(filePath);
    const liveReloadEntry = import_fs_extra2.default.readFileSync(import_path8.default.join(__dirname, "./iife/launch-web-client.js")).toString("utf-8");
    const liveReloadEntryWithOptions = liveReloadEntry.replace(
      WEB_CLIENT_OPTIONS_IDENTIFIER,
      JSON.stringify(options)
    );
    import_fs_extra2.default.writeFileSync(filePath, liveReloadEntryWithOptions);
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      console.log(
        import_chalk3.default`{cyan ${this._options.name} Process(${process.pid}) SIGTERM, mf server will exit...}`
      );
      this._exit(0 /* SUCCESS */);
    });
    process.on("SIGINT", () => {
      console.log(
        import_chalk3.default`{cyan ${this._options.name} Process(${process.pid}) SIGINT, mf server will exit...}`
      );
      this._exit(0 /* SUCCESS */);
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      console.log(
        import_chalk3.default`{cyan ${this._options.name} Process(${process.pid}) unhandledRejection, mf server will exit...}`
      );
      this._exit(1 /* FAILURE */);
    });
    process.on("uncaughtException", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      console.log(
        import_chalk3.default`{cyan ${this._options.name} Process(${process.pid}) uncaughtException, mf server will exit...}`
      );
      this._exit(1 /* FAILURE */);
    });
  }
  _exit(exitCode = 0) {
    var _a;
    (_a = this._devWorker) == null ? void 0 : _a.exit();
    process.exit(exitCode);
  }
  _afterEmit() {
    var _a;
    (_a = this._devWorker) == null ? void 0 : _a.update();
  }
  apply(compiler) {
    const {
      _options: { name, dev, dts }
    } = this;
    const normalizedDev = (0, import_sdk5.normalizeOptions)(
      true,
      {
        disableLiveReload: true,
        disableHotTypesReload: false
      },
      "mfOptions.dev"
    )(dev);
    if (!isDev() || normalizedDev === false) {
      return;
    }
    if (normalizedDev.disableHotTypesReload && normalizedDev.disableLiveReload) {
      return;
    }
    if (!name) {
      throw new Error("name is required if you want to enable dev server!");
    }
    if (!normalizedDev.disableLiveReload) {
      const TEMP_DIR = import_path8.default.join(
        `${process.cwd()}/node_modules`,
        `.federation`
      );
      const filepath = import_path8.default.join(TEMP_DIR, `live-reload.js`);
      _DevPlugin.ensureLiveReloadEntry({ name }, filepath);
      compiler.hooks.afterPlugins.tap("MFDevPlugin", () => {
        new compiler.webpack.EntryPlugin(compiler.context, filepath, {
          name
        }).apply(compiler);
      });
    }
    const defaultGenerateTypes = { compileInChildProcess: true };
    const defaultConsumeTypes = { consumeAPITypes: true };
    const normalizedDtsOptions = (0, import_sdk5.normalizeOptions)(
      isTSProject(dts, compiler.context),
      {
        //  remote types dist(.dev-server) not be used currently, so no need to set extractThirdParty etc
        generateTypes: defaultGenerateTypes,
        consumeTypes: defaultConsumeTypes,
        extraOptions: {}
      },
      "mfOptions.dts"
    )(dts);
    const normalizedGenerateTypes = (0, import_sdk5.normalizeOptions)(
      Boolean(normalizedDtsOptions),
      defaultGenerateTypes,
      "mfOptions.dts.generateTypes"
    )(
      normalizedDtsOptions === false ? void 0 : normalizedDtsOptions.generateTypes
    );
    const remote = normalizedGenerateTypes === false ? void 0 : {
      implementation: normalizedDtsOptions === false ? void 0 : normalizedDtsOptions.implementation,
      context: compiler.context,
      moduleFederationConfig: {
        ...this._options
      },
      hostRemoteTypesFolder: normalizedGenerateTypes.typesFolder || "@mf-types",
      ...normalizedGenerateTypes,
      typesFolder: `.dev-server`
    };
    const normalizedConsumeTypes = (0, import_sdk5.normalizeOptions)(
      Boolean(normalizedDtsOptions),
      defaultConsumeTypes,
      "mfOptions.dts.consumeTypes"
    )(
      normalizedDtsOptions === false ? void 0 : normalizedDtsOptions.consumeTypes
    );
    const host = normalizedConsumeTypes === false ? void 0 : {
      implementation: normalizedDtsOptions === false ? void 0 : normalizedDtsOptions.implementation,
      context: compiler.context,
      moduleFederationConfig: this._options,
      typesFolder: "@mf-types",
      abortOnError: false,
      ...normalizedConsumeTypes
    };
    const extraOptions = normalizedDtsOptions ? normalizedDtsOptions.extraOptions || {} : {};
    if (!remote && !host && normalizedDev.disableLiveReload) {
      return;
    }
    if (remote && !(remote == null ? void 0 : remote.tsConfigPath) && typeof normalizedDtsOptions === "object" && normalizedDtsOptions.tsConfigPath) {
      remote.tsConfigPath = normalizedDtsOptions.tsConfigPath;
    }
    this._devWorker = createDevWorker({
      name,
      remote,
      host,
      extraOptions,
      disableLiveReload: normalizedDev.disableHotTypesReload,
      disableHotTypesReload: normalizedDev.disableHotTypesReload
    });
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
    compiler.hooks.afterEmit.tap(this.name, this._afterEmit.bind(this));
  }
};

// packages/dts-plugin/src/plugins/TypesPlugin.ts
var import_sdk8 = require("@module-federation/sdk");

// packages/dts-plugin/src/plugins/ConsumeTypesPlugin.ts
var import_sdk6 = require("@module-federation/sdk");
var ConsumeTypesPlugin = class {
  constructor(pluginOptions, dtsOptions, defaultOptions3) {
    this.pluginOptions = pluginOptions;
    this.dtsOptions = dtsOptions;
    this.defaultOptions = defaultOptions3;
  }
  apply(compiler) {
    const { dtsOptions, defaultOptions: defaultOptions3, pluginOptions } = this;
    const normalizedConsumeTypes = (0, import_sdk6.normalizeOptions)(
      true,
      defaultOptions3,
      "mfOptions.dts.consumeTypes"
    )(dtsOptions.consumeTypes);
    if (!normalizedConsumeTypes) {
      return;
    }
    const finalOptions = {
      host: {
        implementation: dtsOptions.implementation,
        context: compiler.context,
        moduleFederationConfig: pluginOptions,
        ...normalizedConsumeTypes
      },
      extraOptions: dtsOptions.extraOptions || {}
    };
    validateOptions(finalOptions.host);
    consumeTypes(finalOptions);
  }
};

// packages/dts-plugin/src/plugins/GenerateTypesPlugin.ts
var import_fs4 = __toESM(require("fs"));
var import_sdk7 = require("@module-federation/sdk");
var GenerateTypesPlugin = class {
  constructor(pluginOptions, dtsOptions, defaultOptions3) {
    this.pluginOptions = pluginOptions;
    this.dtsOptions = dtsOptions;
    this.defaultOptions = defaultOptions3;
  }
  apply(compiler) {
    const { dtsOptions, defaultOptions: defaultOptions3, pluginOptions } = this;
    const normalizedGenerateTypes = (0, import_sdk7.normalizeOptions)(
      true,
      defaultOptions3,
      "mfOptions.dts.generateTypes"
    )(dtsOptions.generateTypes);
    if (!normalizedGenerateTypes) {
      return;
    }
    const finalOptions = {
      remote: {
        implementation: dtsOptions.implementation,
        context: compiler.context,
        moduleFederationConfig: pluginOptions,
        ...normalizedGenerateTypes
      },
      extraOptions: dtsOptions.extraOptions || {}
    };
    if (dtsOptions.tsConfigPath && !finalOptions.remote.tsConfigPath) {
      finalOptions.remote.tsConfigPath = dtsOptions.tsConfigPath;
    }
    validateOptions(finalOptions.remote);
    const isProd = !isDev();
    const getGenerateTypesFn = () => {
      let fn = generateTypes;
      let res;
      if (finalOptions.remote.compileInChildProcess) {
        fn = generateTypesInChildProcess;
      }
      if (isProd) {
        res = fn(finalOptions);
        return () => res;
      }
      return fn;
    };
    const generateTypesFn = getGenerateTypesFn();
    compiler.hooks.thisCompilation.tap("mf:generateTypes", (compilation) => {
      compilation.hooks.processAssets.tapPromise(
        {
          name: "mf:generateTypes",
          stage: (
            // @ts-expect-error use runtime variable in case peer dep not installed
            compilation.constructor.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER
          )
        },
        async () => {
          try {
            const { zipTypesPath, apiTypesPath, zipName, apiFileName } = retrieveTypesAssetsInfo(finalOptions.remote);
            if (zipName && compilation.getAsset(zipName)) {
              return;
            }
            await generateTypesFn(finalOptions);
            if (zipTypesPath) {
              compilation.emitAsset(
                zipName,
                new compiler.webpack.sources.RawSource(
                  import_fs4.default.readFileSync(zipTypesPath),
                  false
                )
              );
            }
            if (apiTypesPath) {
              compilation.emitAsset(
                apiFileName,
                new compiler.webpack.sources.RawSource(
                  import_fs4.default.readFileSync(apiTypesPath),
                  false
                )
              );
            }
          } catch (err) {
            console.error(err);
          }
        }
      );
    });
  }
};

// packages/dts-plugin/src/plugins/TypesPlugin.ts
var TypesPlugin = class {
  constructor(options) {
    this.options = options;
  }
  apply(compiler) {
    const { options } = this;
    const defaultGenerateTypes = {
      generateAPITypes: true,
      compileInChildProcess: true,
      abortOnError: false,
      extractThirdParty: true,
      extractRemoteTypes: true
    };
    const defaultConsumeTypes = { abortOnError: false, consumeAPITypes: true };
    const normalizedDtsOptions = (0, import_sdk8.normalizeOptions)(
      isTSProject(options.dts, compiler.context),
      {
        generateTypes: defaultGenerateTypes,
        consumeTypes: defaultConsumeTypes,
        extraOptions: {}
      },
      "mfOptions.dts"
    )(options.dts);
    if (typeof normalizedDtsOptions !== "object") {
      return;
    }
    new GenerateTypesPlugin(
      options,
      normalizedDtsOptions,
      defaultGenerateTypes
    ).apply(compiler);
    new ConsumeTypesPlugin(
      options,
      normalizedDtsOptions,
      defaultConsumeTypes
    ).apply(compiler);
  }
};

// packages/dts-plugin/src/plugins/DtsPlugin.ts
var DtsPlugin = class {
  constructor(options) {
    this.options = options;
  }
  apply(compiler) {
    const { options } = this;
    new DevPlugin(options).apply(compiler);
    new TypesPlugin(options).apply(compiler);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DtsPlugin
});
