"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
    MIT License http://www.opensource.org/licenses/mit-license.php
    Author Tobias Koppers @sokra, Zackary Jackson @ScriptedAlchemy, Marais Rossouw @maraisr
*/
const normalize_webpack_path_1 = require("@module-federation/sdk/normalize-webpack-path");
const ContainerEntryDependency_1 = __importDefault(require("./ContainerEntryDependency"));
const ContainerEntryModuleFactory_1 = __importDefault(require("./ContainerEntryModuleFactory"));
const ContainerExposedDependency_1 = __importDefault(require("./ContainerExposedDependency"));
const options_1 = require("./options");
const FederationRuntimePlugin_1 = __importDefault(require("./runtime/FederationRuntimePlugin"));
const ContainerPlugin_check_1 = __importDefault(require("../../schemas/container/ContainerPlugin.check"));
const ContainerPlugin_1 = __importDefault(require("../../schemas/container/ContainerPlugin"));
const createSchemaValidation = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack/lib/util/create-schema-validation'));
const validate = createSchemaValidation(ContainerPlugin_check_1.default, () => ContainerPlugin_1.default, {
    name: 'Container Plugin',
    baseDataPath: 'options',
});
const PLUGIN_NAME = 'ContainerPlugin';
class ContainerPlugin {
    /**
     * @param {containerPlugin.ContainerPluginOptions} options options
     */
    constructor(options) {
        validate(options);
        this.name = PLUGIN_NAME;
        this._options = {
            name: options.name,
            shareScope: options.shareScope || 'default',
            library: options.library || {
                type: 'var',
                name: options.name,
            },
            runtime: options.runtime,
            filename: options.filename || undefined,
            //@ts-ignore
            exposes: (0, options_1.parseOptions)(options.exposes, (item) => ({
                import: Array.isArray(item) ? item : [item],
                name: undefined,
            }), (item) => ({
                import: Array.isArray(item.import) ? item.import : [item.import],
                name: item.name || undefined,
            })),
            runtimePlugins: options.runtimePlugins,
        };
    }
    // container should not be affected by splitChunks
    static patchChunkSplit(compiler, name) {
        const { splitChunks } = compiler.options.optimization;
        const patchChunkSplit = (cacheGroup) => {
            switch (typeof cacheGroup) {
                case 'boolean':
                case 'string':
                case 'function':
                    break;
                //  cacheGroup.chunks will inherit splitChunks.chunks, so you only need to modify the chunks that are set separately
                case 'object':
                    {
                        if (cacheGroup instanceof RegExp) {
                            break;
                        }
                        if (!cacheGroup.chunks) {
                            break;
                        }
                        if (typeof cacheGroup.chunks === 'function') {
                            const prevChunks = cacheGroup.chunks;
                            cacheGroup.chunks = (chunk) => {
                                if (chunk.name &&
                                    (chunk.name === name || chunk.name === name + '_partial')) {
                                    return false;
                                }
                                return prevChunks(chunk);
                            };
                            break;
                        }
                        if (cacheGroup.chunks === 'all') {
                            cacheGroup.chunks = (chunk) => {
                                if (chunk.name &&
                                    (chunk.name === name || chunk.name === name + '_partial')) {
                                    return false;
                                }
                                return true;
                            };
                            break;
                        }
                        if (cacheGroup.chunks === 'initial') {
                            cacheGroup.chunks = (chunk) => {
                                if (chunk.name &&
                                    (chunk.name === name || chunk.name === name + '_partial')) {
                                    return false;
                                }
                                return chunk.isOnlyInitial();
                            };
                            break;
                        }
                    }
                    break;
            }
        };
        if (!splitChunks) {
            return;
        }
        // patch splitChunk.chunks
        patchChunkSplit(splitChunks);
        const cacheGroups = splitChunks.cacheGroups;
        if (!cacheGroups) {
            return;
        }
        // patch splitChunk.cacheGroups[key].chunks
        Object.keys(cacheGroups).forEach((cacheGroupKey) => {
            patchChunkSplit(cacheGroups[cacheGroupKey]);
        });
    }
    apply(compiler) {
        const useModuleFederationPlugin = compiler.options.plugins.find((p) => {
            if (typeof p !== 'object' || !p) {
                return false;
            }
            return p['name'] === 'ModuleFederationPlugin';
        });
        if (!useModuleFederationPlugin) {
            ContainerPlugin.patchChunkSplit(compiler, this._options.name);
        }
        const federationRuntimePluginInstance = new FederationRuntimePlugin_1.default();
        federationRuntimePluginInstance.apply(compiler);
        const { name, exposes, shareScope, filename, library, runtime } = this._options;
        if (library &&
            compiler.options.output &&
            compiler.options.output.enabledLibraryTypes &&
            !compiler.options.output.enabledLibraryTypes.includes(library.type)) {
            compiler.options.output.enabledLibraryTypes.push(library.type);
        }
        compiler.hooks.make.tapAsync(PLUGIN_NAME, (compilation, callback) => {
            const dep = new ContainerEntryDependency_1.default(name, 
            //@ts-ignore
            exposes, shareScope, federationRuntimePluginInstance.entryFilePath);
            const hasSingleRuntimeChunk = compilation.options?.optimization?.runtimeChunk;
            dep.loc = { name };
            compilation.addEntry(compilation.options.context || '', 
            //@ts-ignore
            dep, {
                name,
                filename,
                runtime: hasSingleRuntimeChunk ? false : runtime,
                library,
            }, (error) => {
                if (error)
                    return callback(error);
                if (hasSingleRuntimeChunk) {
                    // Add to single runtime chunk as well.
                    // Allows for singleton runtime graph with all needed runtime modules for federation
                    addEntryToSingleRuntimeChunk();
                }
                else {
                    callback();
                }
            });
            // Function to add entry for undefined runtime
            const addEntryToSingleRuntimeChunk = () => {
                compilation.addEntry(compilation.options.context || '', 
                //@ts-ignore
                dep, {
                    name: name ? name + '_partial' : undefined, // give unique name name
                    runtime: undefined,
                    library,
                }, (error) => {
                    if (error)
                        return callback(error);
                    callback();
                });
            };
        });
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            compilation.dependencyFactories.set(ContainerEntryDependency_1.default, 
            //@ts-ignore
            new ContainerEntryModuleFactory_1.default());
            compilation.dependencyFactories.set(
            //@ts-ignore
            ContainerExposedDependency_1.default, normalModuleFactory);
        });
    }
}
exports.default = ContainerPlugin;
//# sourceMappingURL=ContainerPlugin.js.map