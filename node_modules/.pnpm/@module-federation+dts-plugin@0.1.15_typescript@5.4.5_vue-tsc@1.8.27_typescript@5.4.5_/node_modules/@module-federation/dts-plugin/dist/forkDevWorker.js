"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/dts-plugin/src/dev-worker/forkDevWorker.ts
var forkDevWorker_exports = {};
__export(forkDevWorker_exports, {
  forkDevWorker: () => forkDevWorker
});
module.exports = __toCommonJS(forkDevWorker_exports);

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var import_fs2 = require("fs");
var import_path5 = require("path");
var import_managers2 = require("@module-federation/managers");
var import_typescript2 = __toESM(require("typescript"));

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_ansi_colors2 = __toESM(require("ansi-colors"));
var import_path4 = __toESM(require("path"));
var import_promises = require("fs/promises");
var import_fs = __toESM(require("fs"));
var import_sdk4 = require("@module-federation/sdk");
var import_lodash = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var import_adm_zip = __toESM(require("adm-zip"));
var import_axios = __toESM(require("axios"));
var import_path3 = require("path");

// packages/dts-plugin/src/core/lib/typeScriptCompiler.ts
var import_ansi_colors = __toESM(require("ansi-colors"));
var import_path = require("path");
var import_typescript = __toESM(require("typescript"));
var import_third_party_dts_extractor = require("@module-federation/third-party-dts-extractor");
var STARTS_WITH_SLASH = /^\//;
var DEFINITION_FILE_EXTENSION = ".d.ts";
var reportCompileDiagnostic = (diagnostic) => {
  const { line } = diagnostic.file.getLineAndCharacterOfPosition(
    diagnostic.start
  );
  console.error(
    import_ansi_colors.default.red(
      `TS Error ${diagnostic.code}':' ${import_typescript.default.flattenDiagnosticMessageText(
        diagnostic.messageText,
        import_typescript.default.sys.newLine
      )}`
    )
  );
  console.error(
    import_ansi_colors.default.red(
      `         at ${diagnostic.file.fileName}:${line + 1} typescript.sys.newLine`
    )
  );
};
var retrieveMfTypesPath = (tsConfig, remoteOptions) => (0, import_path.normalize)(tsConfig.outDir.replace(remoteOptions.compiledTypesFolder, ""));
var retrieveOriginalOutDir = (tsConfig, remoteOptions) => (0, import_path.normalize)(
  tsConfig.outDir.replace(remoteOptions.compiledTypesFolder, "").replace(remoteOptions.typesFolder, "")
);
var retrieveMfAPITypesPath = (tsConfig, remoteOptions) => (0, import_path.join)(
  retrieveOriginalOutDir(tsConfig, remoteOptions),
  `${remoteOptions.typesFolder}.d.ts`
);
var createHost = (mapComponentsToExpose, tsConfig, remoteOptions, cb) => {
  const host = import_typescript.default.createCompilerHost(tsConfig);
  const originalWriteFile = host.writeFile;
  const mapExposeToEntry = Object.fromEntries(
    Object.entries(mapComponentsToExpose).map(([exposed, filename]) => [
      (0, import_path.normalize)(filename),
      exposed
    ])
  );
  const mfTypePath = retrieveMfTypesPath(tsConfig, remoteOptions);
  host.writeFile = (filepath, text, writeOrderByteMark, onError, sourceFiles, data) => {
    originalWriteFile(
      filepath,
      text,
      writeOrderByteMark,
      onError,
      sourceFiles,
      data
    );
    for (const sourceFile of sourceFiles || []) {
      const sourceEntry = mapExposeToEntry[(0, import_path.normalize)(sourceFile.fileName)];
      if (sourceEntry) {
        const mfeTypeEntry = (0, import_path.join)(
          mfTypePath,
          `${sourceEntry}${DEFINITION_FILE_EXTENSION}`
        );
        const mfeTypeEntryDirectory = (0, import_path.dirname)(mfeTypeEntry);
        const relativePathToOutput = (0, import_path.relative)(mfeTypeEntryDirectory, filepath).replace(DEFINITION_FILE_EXTENSION, "").replace(STARTS_WITH_SLASH, "").split(import_path.sep).join("/");
        originalWriteFile(
          mfeTypeEntry,
          `export * from './${relativePathToOutput}';
export { default } from './${relativePathToOutput}';`,
          writeOrderByteMark
        );
      }
    }
    cb(text);
  };
  return host;
};
var createVueTscProgram = (programOptions) => {
  const vueTypescript = require("vue-tsc");
  return vueTypescript.createProgram(programOptions);
};
var createProgram = (remoteOptions, programOptions) => {
  switch (remoteOptions.compilerInstance) {
    case "vue-tsc":
      return createVueTscProgram(programOptions);
    case "tsc":
    default:
      return import_typescript.default.createProgram(programOptions);
  }
};
var compileTs = (mapComponentsToExpose, tsConfig, remoteOptions) => {
  const mfTypePath = retrieveMfTypesPath(tsConfig, remoteOptions);
  const thirdPartyExtractor = new import_third_party_dts_extractor.ThirdPartyExtractor(
    (0, import_path.resolve)(mfTypePath, "node_modules"),
    remoteOptions.context
  );
  const cb = remoteOptions.extractThirdParty ? thirdPartyExtractor.collectPkgs.bind(thirdPartyExtractor) : () => void 0;
  const tsHost = createHost(mapComponentsToExpose, tsConfig, remoteOptions, cb);
  const filesToCompile = [
    ...Object.values(mapComponentsToExpose),
    ...remoteOptions.additionalFilesToCompile
  ];
  const programOptions = {
    rootNames: filesToCompile,
    host: tsHost,
    options: tsConfig
  };
  const tsProgram = createProgram(remoteOptions, programOptions);
  const { diagnostics = [] } = tsProgram.emit();
  diagnostics.forEach(reportCompileDiagnostic);
  if (remoteOptions.extractThirdParty) {
    thirdPartyExtractor.copyDts();
  }
};

// packages/dts-plugin/src/server/message/Message.ts
var Message = class {
  constructor(type, kind) {
    this.type = type;
    this.kind = kind;
    this.time = Date.now();
  }
};

// packages/dts-plugin/src/server/message/API/API.ts
var API = class extends Message {
  constructor(content, kind) {
    super("API", kind);
    const { code, payload } = content;
    this.code = code;
    this.payload = payload;
  }
};

// packages/dts-plugin/src/server/message/API/UpdateSubscriber.ts
var UpdateSubscriberAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "UPDATE_SUBSCRIBER" /* UPDATE_SUBSCRIBER */
    );
  }
};

// packages/dts-plugin/src/server/message/API/ReloadWebClient.ts
var ReloadWebClientAPI = class extends API {
  constructor(payload) {
    super(
      {
        code: 0,
        payload
      },
      "RELOAD_WEB_CLIENT" /* RELOAD_WEB_CLIENT */
    );
  }
};

// packages/dts-plugin/src/server/utils/index.ts
var import_net = __toESM(require("net"));
var import_sdk2 = require("@module-federation/sdk");

// packages/dts-plugin/src/server/utils/logTransform.ts
var import_chalk = __toESM(require("chalk"));

// packages/dts-plugin/src/server/message/Log/Log.ts
var Log = class extends Message {
  constructor(level, kind, ignoreVerbose = false) {
    super("Log", kind);
    this.ignoreVerbose = false;
    this.level = level;
    this.ignoreVerbose = ignoreVerbose;
  }
};

// packages/dts-plugin/src/server/message/Log/BrokerExitLog.ts
var BrokerExitLog = class extends Log {
  constructor() {
    super("LOG" /* LOG */, "BrokerExitLog" /* BrokerExitLog */);
  }
};

// packages/dts-plugin/src/server/utils/log.ts
var import_sdk = require("@module-federation/sdk");
var log4js = __toESM(require("log4js"));
var import_chalk2 = __toESM(require("chalk"));

// packages/dts-plugin/src/server/constant.ts
var DEFAULT_WEB_SOCKET_PORT = 16322;
var WEB_SOCKET_CONNECT_MAGIC_ID = "1hpzW-zo2z-o8io-gfmV1-2cb1d82";
var MF_SERVER_IDENTIFIER = "Module Federation Dev Server";
var DEFAULT_TAR_NAME = "@mf-types.zip";

// packages/dts-plugin/src/server/utils/log.ts
function fileLog(msg, module2, level) {
  var _a, _b;
  if (!((_a = process == null ? void 0 : process.env) == null ? void 0 : _a["FEDERATION_DEBUG"])) {
    return;
  }
  log4js.configure({
    appenders: {
      [module2]: { type: "file", filename: ".mf/typesGenerate.log" },
      default: { type: "file", filename: ".mf/typesGenerate.log" }
    },
    categories: {
      [module2]: { appenders: [module2], level: "error" },
      default: { appenders: ["default"], level: "trace" }
    }
  });
  const logger4 = log4js.getLogger(module2);
  logger4.level = "debug";
  (_b = logger4[level]) == null ? void 0 : _b.call(logger4, msg);
}
function error(error2, action, from) {
  const err = error2 instanceof Error ? error2 : new Error(`${action} error`);
  fileLog(`[${action}] error: ${err}`, from, "fatal");
  return err.toString();
}

// packages/dts-plugin/src/server/utils/getIPV4.ts
var import_os = __toESM(require("os"));
var localIpv4 = "127.0.0.1";
var getIpv4Interfaces = () => {
  try {
    const interfaces = import_os.default.networkInterfaces();
    const ipv4Interfaces = [];
    Object.values(interfaces).forEach((detail) => {
      detail == null ? void 0 : detail.forEach((detail2) => {
        const familyV4Value = typeof detail2.family === "string" ? "IPv4" : 4;
        if (detail2.family === familyV4Value && detail2.address !== localIpv4) {
          ipv4Interfaces.push(detail2);
        }
      });
    });
    return ipv4Interfaces;
  } catch (_err) {
    return [];
  }
};
var getIPV4 = () => {
  const ipv4Interfaces = getIpv4Interfaces();
  const ipv4Interface = ipv4Interfaces[0] || { address: localIpv4 };
  return ipv4Interface.address;
};

// packages/dts-plugin/src/server/utils/index.ts
function getIdentifier(options) {
  const { ip, name } = options;
  return `mf ${import_sdk2.SEPARATOR}${name}${ip ? `${import_sdk2.SEPARATOR}${ip}` : ""}`;
}
function fib(n) {
  let i = 2;
  const res = [0, 1, 1];
  while (i <= n) {
    res[i] = res[i - 1] + res[i - 2];
    i++;
  }
  return res[n];
}
function getFreePort() {
  return new Promise((resolve4, reject) => {
    const server = import_net.default.createServer();
    server.unref();
    server.on("error", reject);
    server.listen(0, () => {
      const { port } = server.address();
      server.close(() => {
        resolve4(port);
      });
    });
  });
}

// packages/dts-plugin/src/server/Publisher.ts
var Publisher = class {
  constructor(ctx) {
    this._name = ctx.name;
    this._ip = ctx.ip;
    this._remoteTypeTarPath = ctx.remoteTypeTarPath;
    this._subscribers = /* @__PURE__ */ new Map();
  }
  get identifier() {
    return getIdentifier({
      name: this._name,
      ip: this._ip
    });
  }
  get name() {
    return this._name;
  }
  get ip() {
    return this._ip;
  }
  get remoteTypeTarPath() {
    return this._remoteTypeTarPath;
  }
  get hasSubscribes() {
    return Boolean(this._subscribers.size);
  }
  get subscribers() {
    return this._subscribers;
  }
  addSubscriber(identifier, subscriber) {
    fileLog(`${this.name} set subscriber: ${identifier}`, "Publisher", "info");
    this._subscribers.set(identifier, subscriber);
  }
  removeSubscriber(identifier) {
    if (this._subscribers.has(identifier)) {
      fileLog(
        `${this.name} removeSubscriber: ${identifier}`,
        "Publisher",
        "warn"
      );
      this._subscribers.delete(identifier);
    }
  }
  notifySubscriber(subscriberIdentifier, options) {
    const subscriber = this._subscribers.get(subscriberIdentifier);
    if (!subscriber) {
      fileLog(
        `[notifySubscriber] ${this.name} notifySubscriber: ${subscriberIdentifier}, does not exits`,
        "Publisher",
        "error"
      );
      return;
    }
    const api = new UpdateSubscriberAPI(options);
    subscriber.send(JSON.stringify(api));
    fileLog(
      `[notifySubscriber] ${this.name} notifySubscriber: ${JSON.stringify(
        subscriberIdentifier
      )}, message: ${JSON.stringify(api)}`,
      "Publisher",
      "info"
    );
  }
  notifySubscribers(options) {
    const api = new UpdateSubscriberAPI(options);
    this.broadcast(api);
  }
  broadcast(message) {
    if (this.hasSubscribes) {
      this._subscribers.forEach((subscriber, key) => {
        fileLog(
          `[BroadCast] ${this.name} notifySubscriber: ${key}, PID: ${process.pid}, message: ${JSON.stringify(message)}`,
          "Publisher",
          "info"
        );
        subscriber.send(JSON.stringify(message));
      });
    } else {
      fileLog(
        `[BroadCast] ${this.name}'s subscribe is empty`,
        "Publisher",
        "warn"
      );
    }
  }
  close() {
    this._subscribers.forEach((_subscriber, identifier) => {
      fileLog(
        `[BroadCast] close ${this.name} remove: ${identifier}`,
        "Publisher",
        "warn"
      );
      this.removeSubscriber(identifier);
    });
  }
};

// packages/dts-plugin/src/server/DevServer.ts
var import_isomorphic_ws2 = __toESM(require("isomorphic-ws"));

// packages/dts-plugin/src/server/broker/Broker.ts
var import_http = require("http");
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_node_schedule = __toESM(require("node-schedule"));
var import_url = require("url");

// packages/dts-plugin/src/server/message/Action/Action.ts
var Action = class extends Message {
  constructor(content, kind) {
    super("Action", kind);
    const { payload } = content;
    this.payload = payload;
  }
};

// packages/dts-plugin/src/server/message/Action/AddPublisher.ts
var AddPublisherAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "ADD_PUBLISHER" /* ADD_PUBLISHER */
    );
  }
};

// packages/dts-plugin/src/server/message/Action/AddSubscriber.ts
var AddSubscriberAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */
    );
  }
};

// packages/dts-plugin/src/server/message/Action/ExitSubscriber.ts
var ExitSubscriberAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */
    );
  }
};

// packages/dts-plugin/src/server/message/Action/ExitPublisher.ts
var ExitPublisherAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "EXIT_PUBLISHER" /* EXIT_PUBLISHER */
    );
  }
};

// packages/dts-plugin/src/server/message/Action/NotifyWebClient.ts
var NotifyWebClientAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */
    );
  }
};

// packages/dts-plugin/src/server/message/Action/UpdatePublisher.ts
var UpdatePublisherAction = class extends Action {
  constructor(payload) {
    super(
      {
        payload
      },
      "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */
    );
  }
};

// packages/dts-plugin/src/server/broker/Broker.ts
var _Broker = class _Broker {
  constructor() {
    // 1.5h
    this._publisherMap = /* @__PURE__ */ new Map();
    this._webClientMap = /* @__PURE__ */ new Map();
    this._tmpSubscriberShelter = /* @__PURE__ */ new Map();
    this._scheduleJob = null;
    this._setSchedule();
    this._startWsServer();
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
  }
  get hasPublishers() {
    return Boolean(this._publisherMap.size);
  }
  async _startWsServer() {
    const wsHandler = (ws, req) => {
      const { url: reqUrl = "" } = req;
      const { query } = (0, import_url.parse)(reqUrl, true);
      const { WEB_SOCKET_CONNECT_MAGIC_ID: WEB_SOCKET_CONNECT_MAGIC_ID2 } = query;
      if (WEB_SOCKET_CONNECT_MAGIC_ID2 === _Broker.WEB_SOCKET_CONNECT_MAGIC_ID) {
        ws.on("message", (message) => {
          try {
            const text = message.toString();
            const action = JSON.parse(text);
            fileLog(`${action == null ? void 0 : action.kind} action received `, "Broker", "info");
            this._takeAction(action, ws);
          } catch (error2) {
            fileLog(`parse action message error: ${error2}`, "Broker", "error");
          }
        });
        ws.on("error", (e) => {
          fileLog(`parse action message error: ${e}`, "Broker", "error");
        });
      } else {
        ws.send("Invalid CONNECT ID.");
        fileLog("Invalid CONNECT ID.", "Broker", "warn");
        ws.close();
      }
    };
    const server = (0, import_http.createServer)();
    this._webSocketServer = new import_isomorphic_ws.default.Server({ noServer: true });
    this._webSocketServer.on("error", (err) => {
      fileLog(`ws error: 
${err.message}
 ${err.stack}`, "Broker", "error");
    });
    this._webSocketServer.on("listening", () => {
      fileLog(
        `WebSocket server is listening on port ${_Broker.DEFAULT_WEB_SOCKET_PORT}`,
        "Broker",
        "info"
      );
    });
    this._webSocketServer.on("connection", wsHandler);
    this._webSocketServer.on("close", (code) => {
      fileLog(`WebSocket Server Close with Code ${code}`, "Broker", "warn");
      this._webSocketServer && this._webSocketServer.close();
      this._webSocketServer = void 0;
    });
    server.on("upgrade", (req, socket, head) => {
      var _a;
      if (req.url) {
        const { pathname } = (0, import_url.parse)(req.url);
        if (pathname === "/") {
          (_a = this._webSocketServer) == null ? void 0 : _a.handleUpgrade(req, socket, head, (ws) => {
            var _a2;
            (_a2 = this._webSocketServer) == null ? void 0 : _a2.emit("connection", ws, req);
          });
        }
      }
    });
    server.listen(_Broker.DEFAULT_WEB_SOCKET_PORT);
  }
  async _takeAction(action, client) {
    const { kind, payload } = action;
    if (kind === "ADD_PUBLISHER" /* ADD_PUBLISHER */) {
      await this._addPublisher(payload, client);
    }
    if (kind === "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */) {
      await this._updatePublisher(
        payload,
        client
      );
    }
    if (kind === "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */) {
      await this._addSubscriber(payload, client);
    }
    if (kind === "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */) {
      await this._removeSubscriber(
        payload,
        client
      );
    }
    if (kind === "EXIT_PUBLISHER" /* EXIT_PUBLISHER */) {
      await this._removePublisher(payload, client);
    }
    if (kind === "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */) {
      await this._addWebClient(payload, client);
    }
    if (kind === "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */) {
      await this._notifyWebClient(
        payload,
        client
      );
    }
  }
  async _addPublisher(context, client) {
    const { name, ip, remoteTypeTarPath } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (this._publisherMap.has(identifier)) {
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} has been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = new Publisher({ name, ip, remoteTypeTarPath });
      this._publisherMap.set(identifier, publisher);
      fileLog(
        `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] ${identifier} Adding Publisher Succeed`,
        "Broker",
        "info"
      );
      const tmpSubScribers = this._getTmpSubScribers(identifier);
      if (tmpSubScribers) {
        fileLog(
          `[${"ADD_PUBLISHER" /* ADD_PUBLISHER */}] consumeTmpSubscriber set ${publisher.name}\u2019s subscribers `,
          "Broker",
          "info"
        );
        this._consumeTmpSubScribers(publisher, tmpSubScribers);
        this._clearTmpSubScriberRelation(identifier);
      }
    } catch (err) {
      const msg = error(err, "ADD_PUBLISHER" /* ADD_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _updatePublisher(context, client) {
    const {
      name,
      updateMode,
      updateKind,
      updateSourcePaths,
      remoteTypeTarPath,
      ip
    } = context ?? {};
    const identifier = getIdentifier({ name, ip });
    if (!this._publisherMap.has(identifier)) {
      fileLog(
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} has not been started, this action will be ignored
        this._publisherMap: ${JSON.stringify(this._publisherMap.entries())}
        `,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const publisher = this._publisherMap.get(identifier);
      fileLog(
        // eslint-disable-next-line max-len
        `[${"UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */}] ${identifier} update, and notify subscribers to update`,
        "Broker",
        "info"
      );
      if (publisher) {
        publisher.notifySubscribers({
          remoteTypeTarPath,
          name,
          updateMode,
          updateKind,
          updateSourcePaths: updateSourcePaths || []
        });
      }
    } catch (err) {
      const msg = error(err, "UPDATE_PUBLISHER" /* UPDATE_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  //  app1 consumes provider1,provider2. Dependencies at this time: publishers: [provider1, provider2], subscriberName: app1
  // provider1 is app1's remote
  async _addSubscriber(context, client) {
    const { publishers, name: subscriberName } = context ?? {};
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({ name, ip });
      if (!this._publisherMap.has(identifier)) {
        fileLog(
          `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has not been started, ${subscriberName} will add the relation to tmp shelter`,
          "Broker",
          "warn"
        );
        this._addTmpSubScriberRelation(
          {
            name: getIdentifier({
              name: context.name,
              ip: context.ip
            }),
            client
          },
          publisher
        );
        return;
      }
      try {
        const registeredPublisher = this._publisherMap.get(identifier);
        if (registeredPublisher) {
          registeredPublisher.addSubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            client
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: ${identifier} has been started, Adding Subscriber ${subscriberName} Succeed, this.__publisherMap are: ${JSON.stringify(
              Array.from(this._publisherMap.entries())
            )}`,
            "Broker",
            "info"
          );
          registeredPublisher.notifySubscriber(
            getIdentifier({
              name: subscriberName,
              ip: context.ip
            }),
            {
              updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
              updateMode: "PASSIVE" /* PASSIVE */,
              updateSourcePaths: [registeredPublisher.name],
              remoteTypeTarPath: registeredPublisher.remoteTypeTarPath,
              name: registeredPublisher.name
            }
          );
          fileLog(
            // eslint-disable-next-line @ies/eden/max-calls-in-template
            `[${"ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */}]: notifySubscriber Subscriber ${subscriberName}, updateMode: "PASSIVE",  updateSourcePaths: ${registeredPublisher.name}`,
            "Broker",
            "info"
          );
        }
      } catch (err) {
        const msg = error(err, "ADD_SUBSCRIBER" /* ADD_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  // Trigger while consumer exit
  async _removeSubscriber(context, client) {
    const { publishers } = context ?? {};
    const subscriberIdentifier = getIdentifier({
      name: context == null ? void 0 : context.name,
      ip: context == null ? void 0 : context.ip
    });
    publishers.forEach((publisher) => {
      const { name, ip } = publisher;
      const identifier = getIdentifier({
        name,
        ip
      });
      const registeredPublisher = this._publisherMap.get(identifier);
      if (!registeredPublisher) {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} does not exit `,
          "Broker",
          "warn"
        );
        return;
      }
      try {
        fileLog(
          `[${"EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */}], ${identifier} will exit `,
          "Broker",
          "INFO"
        );
        registeredPublisher.removeSubscriber(subscriberIdentifier);
        this._clearTmpSubScriberRelation(identifier);
        if (!registeredPublisher.hasSubscribes) {
          this._publisherMap.delete(identifier);
        }
        if (!this.hasPublishers) {
          this.exit();
        }
      } catch (err) {
        const msg = error(err, "EXIT_SUBSCRIBER" /* EXIT_SUBSCRIBER */, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  async _removePublisher(context, client) {
    const { name, ip } = context ?? {};
    const identifier = getIdentifier({
      name,
      ip
    });
    const publisher = this._publisherMap.get(identifier);
    if (!publisher) {
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier}} has not been added, this action will be ingored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const { subscribers } = publisher;
      subscribers.forEach((subscriber, subscriberIdentifier) => {
        this._addTmpSubScriberRelation(
          {
            name: subscriberIdentifier,
            client: subscriber
          },
          { name: publisher.name, ip: publisher.ip }
        );
        fileLog(
          // eslint-disable-next-line max-len
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removing , subscriber: ${subscriberIdentifier} will be add  tmpSubScriberRelation`,
          "Broker",
          "info"
        );
      });
      this._publisherMap.delete(identifier);
      fileLog(
        `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: ${identifier} is removed `,
        "Broker",
        "info"
      );
      if (!this.hasPublishers) {
        fileLog(
          `[${"EXIT_PUBLISHER" /* EXIT_PUBLISHER */}]: _publisherMap is empty, all server will exit `,
          "Broker",
          "warn"
        );
        this.exit();
      }
    } catch (err) {
      const msg = error(err, "EXIT_PUBLISHER" /* EXIT_PUBLISHER */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _addWebClient(context, client) {
    const { name } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    if (this._webClientMap.has(identifier)) {
      fileLog(
        `${identifier}} has been added, this action will override prev WebClient`,
        "Broker",
        "warn"
      );
    }
    try {
      this._webClientMap.set(identifier, client);
      fileLog(`${identifier} adding WebClient Succeed`, "Broker", "info");
    } catch (err) {
      const msg = error(err, "ADD_WEB_CLIENT" /* ADD_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  async _notifyWebClient(context, client) {
    const { name, updateMode } = context ?? {};
    const identifier = getIdentifier({
      name
    });
    const webClient = this._webClientMap.get(identifier);
    if (!webClient) {
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] ${identifier} has not been added, this action will be ignored`,
        "Broker",
        "warn"
      );
      return;
    }
    try {
      const api = new ReloadWebClientAPI({ name, updateMode });
      webClient.send(JSON.stringify(api));
      fileLog(
        `[${"NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */}] Notify ${name} WebClient Succeed`,
        "Broker",
        "info"
      );
    } catch (err) {
      const msg = error(err, "NOTIFY_WEB_CLIENT" /* NOTIFY_WEB_CLIENT */, "Broker");
      client.send(msg);
      client.close();
    }
  }
  // app1 consumes provider1, and provider1 not launch. this._tmpSubscriberShelter at this time: {provider1: Map{subscribers: Map{app1: app1+ip+client'}, timestamp: 'xx'} }
  _addTmpSubScriberRelation(subscriber, publisher) {
    const publisherIdentifier = getIdentifier({
      name: publisher.name,
      ip: publisher.ip
    });
    const subscriberIdentifier = subscriber.name;
    const shelter = this._tmpSubscriberShelter.get(publisherIdentifier);
    if (!shelter) {
      const map = /* @__PURE__ */ new Map();
      map.set(subscriberIdentifier, subscriber);
      this._tmpSubscriberShelter.set(publisherIdentifier, {
        subscribers: map,
        timestamp: Date.now()
      });
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier}'s subscriber has ${subscriberIdentifier} `,
        "Broker",
        "info"
      );
      return;
    }
    const tmpSubScriberShelterSubscriber = shelter.subscribers.get(subscriberIdentifier);
    if (tmpSubScriberShelterSubscriber) {
      fileLog(
        `[AddTmpSubscriberRelation] ${publisherIdentifier} and ${subscriberIdentifier} relation has been added`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
      shelter.timestamp = Date.now();
    } else {
      fileLog(
        // eslint-disable-next-line max-len
        `AddTmpSubscriberLog ${publisherIdentifier}'s shelter has been added, update shelter.subscribers ${subscriberIdentifier}`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
    }
  }
  _getTmpSubScribers(publisherIdentifier) {
    var _a;
    return (_a = this._tmpSubscriberShelter.get(publisherIdentifier)) == null ? void 0 : _a.subscribers;
  }
  // after adding publisher, it will change the temp subscriber to regular subscriber
  _consumeTmpSubScribers(publisher, tmpSubScribers) {
    tmpSubScribers.forEach((tmpSubScriber, identifier) => {
      fileLog(
        `notifyTmpSubScribers ${publisher.name} will be add a subscriber: ${identifier} `,
        "Broker",
        "warn"
      );
      publisher.addSubscriber(identifier, tmpSubScriber.client);
      publisher.notifySubscriber(identifier, {
        updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
        updateMode: "PASSIVE" /* PASSIVE */,
        updateSourcePaths: [publisher.name],
        remoteTypeTarPath: publisher.remoteTypeTarPath,
        name: publisher.name
      });
    });
  }
  _clearTmpSubScriberRelation(identifier) {
    this._tmpSubscriberShelter.delete(identifier);
  }
  _clearTmpSubScriberRelations() {
    this._tmpSubscriberShelter.clear();
  }
  _disconnect() {
    this._publisherMap.forEach((publisher) => {
      publisher.close();
    });
  }
  // Every day on 0/6/9/12/15//18, Publishers that have not been connected within 1.5 hours will be cleared regularly.
  // If process.env.FEDERATION_SERVER_TEST is set, it will be read at a specified time.
  _setSchedule() {
    const rule = new import_node_schedule.default.RecurrenceRule();
    if (Number(process.env["FEDERATION_SERVER_TEST"])) {
      const interval = Number(process.env["FEDERATION_SERVER_TEST"]) / 1e3;
      const second = [];
      for (let i = 0; i < 60; i = i + interval) {
        second.push(i);
      }
      rule.second = second;
    } else {
      rule.second = 0;
      rule.hour = [0, 3, 6, 9, 12, 15, 18];
      rule.minute = 0;
    }
    const serverTest = Number(process.env["FEDERATION_SERVER_TEST"]);
    this._scheduleJob = import_node_schedule.default.scheduleJob(rule, () => {
      this._tmpSubscriberShelter.forEach((tmpSubscriber, identifier) => {
        fileLog(
          ` _clearTmpSubScriberRelation ${identifier},  ${Date.now() - tmpSubscriber.timestamp >= (process.env["GARFISH_MODULE_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)}`,
          "Broker",
          "info"
        );
        if (Date.now() - tmpSubscriber.timestamp >= (process.env["FEDERATION_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)) {
          this._clearTmpSubScriberRelation(identifier);
        }
      });
    });
  }
  _clearSchedule() {
    if (!this._scheduleJob) {
      return;
    }
    this._scheduleJob.cancel();
    this._scheduleJob = null;
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      this.exit();
    });
    process.on("SIGINT", () => {
      this.exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
    process.on("uncaughtException", (error2) => {
      console.error("Unhandled Exception Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
  }
  async start() {
  }
  exit() {
    const brokerExitLog = new BrokerExitLog();
    this.broadcast(JSON.stringify(brokerExitLog));
    this._disconnect();
    this._clearSchedule();
    this._clearTmpSubScriberRelations();
    this._webSocketServer && this._webSocketServer.close();
    this._secureWebSocketServer && this._secureWebSocketServer.close();
    process.exit(0);
  }
  broadcast(message) {
    var _a, _b;
    fileLog(
      `[broadcast] exit info : ${JSON.stringify(message)}`,
      "Broker",
      "warn"
    );
    (_a = this._webSocketServer) == null ? void 0 : _a.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
    (_b = this._secureWebSocketServer) == null ? void 0 : _b.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
  }
};
_Broker.WEB_SOCKET_CONNECT_MAGIC_ID = WEB_SOCKET_CONNECT_MAGIC_ID;
_Broker.DEFAULT_WEB_SOCKET_PORT = DEFAULT_WEB_SOCKET_PORT;
_Broker.DEFAULT_SECURE_WEB_SOCKET_PORT = 16324;
_Broker.DEFAULT_WAITING_TIME = 1.5 * 60 * 60 * 1e3;
var Broker = _Broker;

// packages/dts-plugin/src/server/broker/createBroker.ts
var import_child_process = require("child_process");
var import_path2 = __toESM(require("path"));
function createBroker() {
  const startBrokerPath = import_path2.default.resolve(__dirname, "./startBroker.js");
  const sub = (0, import_child_process.fork)(startBrokerPath, [], {
    detached: true,
    stdio: "ignore",
    env: process.env
  });
  sub.send("start");
  sub.unref();
  return sub;
}

// packages/dts-plugin/src/server/DevServer.ts
var ModuleFederationDevServer = class {
  constructor(ctx) {
    this._publishWebSocket = null;
    this._subscriberWebsocketMap = {};
    this._reconnect = true;
    this._reconnectTimes = 0;
    this._isConnected = false;
    this._isReconnecting = false;
    this._updateCallback = () => Promise.resolve(void 0);
    const { name, remotes, remoteTypeTarPath, updateCallback: updateCallback2 } = ctx;
    this._ip = getIPV4();
    this._name = name;
    this._remotes = remotes;
    this._remoteTypeTarPath = remoteTypeTarPath;
    this._updateCallback = updateCallback2;
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
    this._connectPublishToServer();
  }
  _connectPublishToServer() {
    if (!this._reconnect) {
      return;
    }
    fileLog(
      `Publisher:${this._name} Trying to connect to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`,
      MF_SERVER_IDENTIFIER,
      "info"
    );
    this._publishWebSocket = new import_isomorphic_ws2.default(
      `ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}?WEB_SOCKET_CONNECT_MAGIC_ID=${Broker.WEB_SOCKET_CONNECT_MAGIC_ID}`
    );
    this._publishWebSocket.on("open", () => {
      var _a;
      fileLog(
        `Current pid: ${process.pid}, publisher:${this._name} connected to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}, starting service...`,
        MF_SERVER_IDENTIFIER,
        "info"
      );
      this._isConnected = true;
      const startGarfishModule = new AddPublisherAction({
        name: this._name,
        ip: this._ip,
        remoteTypeTarPath: this._remoteTypeTarPath
      });
      (_a = this._publishWebSocket) == null ? void 0 : _a.send(JSON.stringify(startGarfishModule));
      this._connectSubscribers();
    });
    this._publishWebSocket.on("message", (message) => {
      var _a, _b;
      try {
        const parsedMessage = JSON.parse(
          message.toString()
        );
        if (parsedMessage.type === "Log") {
          if (parsedMessage.kind === "BrokerExitLog" /* BrokerExitLog */) {
            fileLog(
              `Receive broker exit signal, ${this._name} service will exit...`,
              MF_SERVER_IDENTIFIER,
              "warn"
            );
            this._exit();
          }
        }
      } catch (err) {
        console.error(err);
        const exitPublisher = new ExitPublisherAction({
          name: this._name,
          ip: this._ip
        });
        const exitSubscriber = new ExitSubscriberAction({
          name: this._name,
          ip: this._ip,
          publishers: this._remotes.map((remote) => ({
            name: remote.name,
            ip: remote.ip
          }))
        });
        (_a = this._publishWebSocket) == null ? void 0 : _a.send(JSON.stringify(exitPublisher));
        (_b = this._publishWebSocket) == null ? void 0 : _b.send(JSON.stringify(exitSubscriber));
        fileLog(
          "Parse messages error, ModuleFederationDevServer will exit...",
          MF_SERVER_IDENTIFIER,
          "fatal"
        );
        this._exit();
      }
    });
    this._publishWebSocket.on("close", (code) => {
      fileLog(
        `Connection closed with code ${code}.`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      this._publishWebSocket && this._publishWebSocket.close();
      this._publishWebSocket = null;
      if (!this._reconnect) {
        return;
      }
      const reconnectTime = fib(++this._reconnectTimes);
      fileLog(
        `start reconnecting to server after ${reconnectTime}s.`,
        MF_SERVER_IDENTIFIER,
        "info"
      );
      setTimeout(() => this._connectPublishToServer(), reconnectTime * 1e3);
    });
    this._publishWebSocket.on(
      "error",
      this._tryCreateBackgroundBroker.bind(this)
    );
  }
  // Associate the remotes(Subscriber) to the Broker
  _connectSubscriberToServer(remote) {
    const { name, ip } = remote;
    fileLog(
      `remote module:${name} trying to connect to  ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`,
      MF_SERVER_IDENTIFIER,
      "info"
    );
    const identifier = getIdentifier({
      name,
      ip
    });
    this._subscriberWebsocketMap[identifier] = new import_isomorphic_ws2.default(
      `ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}?WEB_SOCKET_CONNECT_MAGIC_ID=${Broker.WEB_SOCKET_CONNECT_MAGIC_ID}`
    );
    this._subscriberWebsocketMap[identifier].on("open", () => {
      fileLog(
        `Current pid: ${process.pid} remote module: ${name} connected to ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}, starting service...`,
        MF_SERVER_IDENTIFIER,
        "info"
      );
      const addSubscriber = new AddSubscriberAction({
        name: this._name,
        // module self name
        ip: this._ip,
        publishers: [
          {
            name,
            // remote's name
            ip
          }
        ]
      });
      this._subscriberWebsocketMap[identifier].send(
        JSON.stringify(addSubscriber)
      );
    });
    this._subscriberWebsocketMap[identifier].on("message", async (message) => {
      try {
        const parsedMessage = JSON.parse(
          message.toString()
        );
        if (parsedMessage.type === "Log") {
          if (parsedMessage.kind === "BrokerExitLog" /* BrokerExitLog */) {
            fileLog(
              `${identifier}'s Server exit, thus ${identifier} will no longer has reload ability.`,
              MF_SERVER_IDENTIFIER,
              "warn"
            );
            this._exit();
          }
        }
        if (parsedMessage.type === "API") {
          if (parsedMessage.kind === "UPDATE_SUBSCRIBER" /* UPDATE_SUBSCRIBER */) {
            const {
              payload: {
                updateKind,
                updateSourcePaths,
                name: subscribeName,
                remoteTypeTarPath,
                updateMode
              }
            } = parsedMessage;
            await this._updateSubscriber({
              remoteTypeTarPath,
              name: subscribeName,
              updateKind,
              updateMode,
              updateSourcePaths
            });
          }
        }
      } catch (err) {
        console.error(err);
        const exitSubscriber = new ExitSubscriberAction({
          name: this._name,
          ip: this._ip,
          publishers: [
            {
              name,
              ip
            }
          ]
        });
        this._subscriberWebsocketMap[identifier].send(
          JSON.stringify(exitSubscriber)
        );
        fileLog(
          `${identifier} exit,
        error: ${err instanceof Error ? err.toString() : JSON.stringify(err)}
        `,
          MF_SERVER_IDENTIFIER,
          "warn"
        );
      }
    });
    this._subscriberWebsocketMap[identifier].on("close", (code) => {
      fileLog(
        `Connection closed with code ${code}.`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      this._subscriberWebsocketMap[identifier] && this._subscriberWebsocketMap[identifier].close();
      delete this._subscriberWebsocketMap[identifier];
    });
  }
  _connectSubscribers() {
    this._remotes.forEach((remote) => {
      this._connectSubscriberToServer(remote);
    });
  }
  // app1 consumes provider1. And the function will be triggered when provider1 code change.
  async _updateSubscriber(options) {
    var _a;
    const {
      updateMode,
      updateKind,
      updateSourcePaths,
      name,
      remoteTypeTarPath
    } = options;
    if (updateMode === "PASSIVE" /* PASSIVE */ && updateSourcePaths.includes(this._name)) {
      fileLog(
        // eslint-disable-next-line max-len
        `[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths} includes ${this._name}, update ignore!`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      return;
    }
    if (updateSourcePaths.slice(-1)[0] === this._name) {
      fileLog(
        `[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths} ends is ${this._name}, update ignore!`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      return;
    }
    fileLog(
      // eslint-disable-next-line max-len
      `[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths}, current module:${this._name}, update start...`,
      MF_SERVER_IDENTIFIER,
      "info"
    );
    await this._updateCallback({
      name,
      updateMode,
      updateKind,
      updateSourcePaths,
      remoteTypeTarPath
    });
    const newUpdateSourcePaths = updateSourcePaths.concat(this._name);
    const updatePublisher = new UpdatePublisherAction({
      name: this._name,
      ip: this._ip,
      updateMode: "PASSIVE" /* PASSIVE */,
      updateKind,
      updateSourcePaths: newUpdateSourcePaths,
      remoteTypeTarPath: this._remoteTypeTarPath
    });
    fileLog(
      // eslint-disable-next-line max-len
      `[_updateSubscriber] run, updateSourcePaths:${newUpdateSourcePaths}, update publisher ${this._name} start...`,
      MF_SERVER_IDENTIFIER,
      "info"
    );
    (_a = this._publishWebSocket) == null ? void 0 : _a.send(JSON.stringify(updatePublisher));
  }
  _tryCreateBackgroundBroker(err) {
    if (!((err == null ? void 0 : err.code) === "ECONNREFUSED" && err.port === Broker.DEFAULT_WEB_SOCKET_PORT)) {
      fileLog(`websocket error: ${err.stack}`, MF_SERVER_IDENTIFIER, "fatal");
      return;
    }
    fileLog(
      `Failed to connect to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`,
      MF_SERVER_IDENTIFIER,
      "fatal"
    );
    this._isReconnecting = true;
    setTimeout(
      () => {
        this._isReconnecting = false;
        if (this._reconnect === false) {
          return;
        }
        fileLog(
          "Creating new background broker...",
          MF_SERVER_IDENTIFIER,
          "warn"
        );
        const broker = createBroker();
        broker.on("message", (message) => {
          if (message === "ready") {
            fileLog("background broker started.", MF_SERVER_IDENTIFIER, "info");
            this._reconnectTimes = 1;
            if (process.send) {
              process.send("ready");
            }
          }
        });
      },
      Math.ceil(100 * Math.random())
    );
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      fileLog(
        `Process(${process.pid}) SIGTERM, ModuleFederationDevServer will exit...`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      this._exit();
    });
    process.on("SIGINT", () => {
      fileLog(
        `Process(${process.pid}) SIGINT, ModuleFederationDevServer will exit...`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      this._exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      if (this._isReconnecting) {
        return;
      }
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(
        `Process(${process.pid}) unhandledRejection, garfishModuleServer will exit...`,
        MF_SERVER_IDENTIFIER,
        "error"
      );
      this._exit();
    });
    process.on("uncaughtException", (error2) => {
      if (this._isReconnecting) {
        return;
      }
      console.error("Unhandled Exception Error: ", error2);
      fileLog(
        `Process(${process.pid}) uncaughtException, garfishModuleServer will exit...`,
        MF_SERVER_IDENTIFIER,
        "error"
      );
      this._exit();
    });
  }
  _exit() {
    this._reconnect = false;
    if (this._publishWebSocket) {
      const exitPublisher = new ExitPublisherAction({
        name: this._name,
        ip: this._ip
      });
      this._publishWebSocket.send(JSON.stringify(exitPublisher));
      this._publishWebSocket.on("message", (message) => {
        const parsedMessage = JSON.parse(
          message.toString()
        );
        fileLog(
          `[${parsedMessage.kind}]: ${JSON.stringify(parsedMessage)}`,
          MF_SERVER_IDENTIFIER,
          "info"
        );
      });
    }
    if (this._publishWebSocket) {
      this._publishWebSocket.close();
      this._publishWebSocket = null;
    }
    process.exit(0);
  }
  exit() {
    this._exit();
  }
  update(options) {
    if (!this._publishWebSocket || !this._isConnected) {
      return;
    }
    const { updateKind, updateMode, updateSourcePaths } = options;
    fileLog(
      `update run, ${this._name} module update, updateKind: ${updateKind}, updateMode: ${updateMode}, updateSourcePaths: ${updateSourcePaths}`,
      MF_SERVER_IDENTIFIER,
      "info"
    );
    if (updateKind === "RELOAD_PAGE" /* RELOAD_PAGE */) {
      const notifyWebClient = new NotifyWebClientAction({
        name: this._name,
        updateMode
      });
      this._publishWebSocket.send(JSON.stringify(notifyWebClient));
      return;
    }
    const updatePublisher = new UpdatePublisherAction({
      name: this._name,
      ip: this._ip,
      updateMode,
      updateKind,
      updateSourcePaths: [this._name],
      remoteTypeTarPath: this._remoteTypeTarPath
    });
    this._publishWebSocket.send(JSON.stringify(updatePublisher));
  }
};

// packages/dts-plugin/src/server/createKoaServer.ts
var import_fs_extra = __toESM(require("fs-extra"));
var import_koa = __toESM(require("koa"));
async function createKoaServer(options) {
  const { typeTarPath } = options;
  const freeport = await getFreePort();
  const app = new import_koa.default();
  app.use(async (ctx, next) => {
    if (ctx.path === `/${DEFAULT_TAR_NAME}`) {
      ctx.status = 200;
      ctx.body = import_fs_extra.default.createReadStream(typeTarPath);
      ctx.response.type = "application/x-gzip";
    } else {
      await next();
    }
  });
  app.listen(freeport);
  return {
    server: app,
    serverAddress: `http://${getIPV4()}:${freeport}`
  };
}

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var retrieveTypesZipPath = (mfTypesPath, remoteOptions) => (0, import_path3.join)(
  mfTypesPath.replace(remoteOptions.typesFolder, ""),
  `${remoteOptions.typesFolder}.zip`
);
var createTypesArchive = async (tsConfig, remoteOptions) => {
  const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
  const zip = new import_adm_zip.default();
  zip.addLocalFolder(mfTypesPath);
  return zip.writeZipPromise(retrieveTypesZipPath(mfTypesPath, remoteOptions));
};
var downloadErrorLogger = (destinationFolder, fileToDownload) => (reason) => {
  throw {
    ...reason,
    message: `Network error: Unable to download federated mocks for '${destinationFolder}' from '${fileToDownload}' because '${reason.message}'`
  };
};
var retrieveTypesArchiveDestinationPath = (hostOptions, destinationFolder) => {
  return (0, import_path3.resolve)(
    hostOptions.context,
    hostOptions.typesFolder,
    destinationFolder
  );
};
var downloadTypesArchive = (hostOptions) => {
  let retries = 0;
  return async ([destinationFolder, fileToDownload]) => {
    const destinationPath = retrieveTypesArchiveDestinationPath(
      hostOptions,
      destinationFolder
    );
    while (retries++ < hostOptions.maxRetries) {
      try {
        const url = fileToDownload;
        const response = await import_axios.default.get(url, { responseType: "arraybuffer" }).catch(downloadErrorLogger(destinationFolder, url));
        const zip = new import_adm_zip.default(Buffer.from(response.data));
        zip.extractAllTo(destinationPath, true);
        return [destinationFolder, destinationPath];
      } catch (error2) {
        fileLog(
          `Error during types archive download: ${(error2 == null ? void 0 : error2.message) || "unknown error"}`,
          "downloadTypesArchive",
          "error"
        );
        if (retries >= hostOptions.maxRetries) {
          if (hostOptions.abortOnError !== false) {
            throw error2;
          }
          return void 0;
        }
      }
    }
  };
};

// packages/dts-plugin/src/core/configurations/hostPlugin.ts
var import_sdk3 = require("@module-federation/sdk");
var import_managers = require("@module-federation/managers");
var defaultOptions = {
  typesFolder: "@mf-types",
  remoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  maxRetries: 3,
  implementation: "",
  context: process.cwd(),
  abortOnError: true,
  consumeAPITypes: false
};
var buildZipUrl = (hostOptions, url) => {
  const remoteUrl = new URL(url);
  const pathnameWithoutEntry = remoteUrl.pathname.split("/").slice(0, -1).join("/");
  remoteUrl.pathname = `${pathnameWithoutEntry}/${hostOptions.remoteTypesFolder}.zip`;
  return remoteUrl.href;
};
var buildApiTypeUrl = (zipUrl) => {
  if (!zipUrl) {
    return void 0;
  }
  return zipUrl.replace(".zip", ".d.ts");
};
var retrieveRemoteInfo = (options) => {
  const { hostOptions, remoteAlias, remote } = options;
  const parsedInfo = (0, import_sdk3.parseEntry)(remote, void 0, "@");
  const url = "entry" in parsedInfo ? parsedInfo.entry : parsedInfo.name === remote ? remote : "";
  const zipUrl = url ? buildZipUrl(hostOptions, url) : "";
  return {
    name: parsedInfo.name || remoteAlias,
    url,
    zipUrl,
    apiTypeUrl: buildApiTypeUrl(zipUrl),
    alias: remoteAlias
  };
};
var resolveRemotes = (hostOptions) => {
  const parsedOptions = import_managers.utils.parseOptions(
    hostOptions.moduleFederationConfig.remotes || {},
    (item, key) => ({
      remote: Array.isArray(item) ? item[0] : item,
      key
    }),
    (item, key) => ({
      remote: Array.isArray(item.external) ? item.external[0] : item.external,
      key
    })
  );
  return parsedOptions.reduce(
    (accumulator, item) => {
      const { key, remote } = item[1];
      accumulator[key] = retrieveRemoteInfo({
        hostOptions,
        remoteAlias: key,
        remote
      });
      return accumulator;
    },
    {}
  );
};
var retrieveHostConfig = (options) => {
  validateOptions(options);
  const hostOptions = { ...defaultOptions, ...options };
  const mapRemotesToDownload = resolveRemotes(hostOptions);
  return {
    hostOptions,
    mapRemotesToDownload
  };
};

// packages/dts-plugin/src/core/constant.ts
var REMOTE_ALIAS_IDENTIFIER = "REMOTE_ALIAS_IDENTIFIER";
var REMOTE_API_TYPES_FILE_NAME = "apis.d.ts";
var HOST_API_TYPES_FILE_NAME = "index.d.ts";

// packages/dts-plugin/src/core/lib/DTSManager.ts
var import_axios2 = __toESM(require("axios"));
var DTSManager = class {
  constructor(options) {
    this.options = (0, import_lodash.default)(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.runtimePkgs = [
      "@module-federation/runtime",
      "@module-federation/enhanced/runtime",
      "@module-federation/runtime-tools"
    ];
    this.loadedRemoteAPIAlias = [];
    this.remoteAliasMap = {};
    this.extraOptions = (options == null ? void 0 : options.extraOptions) || {};
  }
  generateAPITypes(mapComponentsToExpose) {
    const exposePaths = /* @__PURE__ */ new Set();
    const packageType = Object.keys(mapComponentsToExpose).reduce(
      (sum, exposeKey) => {
        const exposePath = import_path4.default.join(REMOTE_ALIAS_IDENTIFIER, exposeKey).split(import_path4.default.sep).join("/");
        exposePaths.add(`'${exposePath}'`);
        const curType = `T extends '${exposePath}' ? typeof import('${exposePath}') :`;
        sum = curType + sum;
        return sum;
      },
      "any;"
    );
    const exposePathKeys = [...exposePaths].join(" | ");
    return `
    export type RemoteKeys = ${exposePathKeys};
    type PackageType<T> = ${packageType}`;
  }
  async extractRemoteTypes(options) {
    const { remoteOptions, tsConfig } = options;
    if (!remoteOptions.extractRemoteTypes) {
      return;
    }
    let hasRemotes = false;
    const remotes = remoteOptions.moduleFederationConfig.remotes;
    if (remotes) {
      if (Array.isArray(remotes)) {
        hasRemotes = Boolean(remotes.length);
      } else if (typeof remotes === "object") {
        hasRemotes = Boolean(Object.keys(remotes).length);
      }
    }
    const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
    if (hasRemotes) {
      const tempHostOptions = {
        moduleFederationConfig: remoteOptions.moduleFederationConfig,
        typesFolder: import_path4.default.join(mfTypesPath, "node_modules"),
        remoteTypesFolder: (remoteOptions == null ? void 0 : remoteOptions.hostRemoteTypesFolder) || remoteOptions.typesFolder,
        deleteTypesFolder: true,
        context: remoteOptions.context,
        implementation: remoteOptions.implementation,
        abortOnError: false
      };
      await this.consumeArchiveTypes(tempHostOptions);
    }
  }
  async generateTypes() {
    var _a;
    try {
      const { options } = this;
      if (!options.remote) {
        throw new Error(
          "options.remote is required if you want to generateTypes"
        );
      }
      const { remoteOptions, tsConfig, mapComponentsToExpose } = retrieveRemoteConfig(options.remote);
      if (!Object.keys(mapComponentsToExpose).length) {
        return;
      }
      this.extractRemoteTypes({
        remoteOptions,
        tsConfig,
        mapComponentsToExpose
      });
      compileTs(mapComponentsToExpose, tsConfig, remoteOptions);
      await createTypesArchive(tsConfig, remoteOptions);
      let apiTypesPath = "";
      if (remoteOptions.generateAPITypes) {
        const apiTypes = this.generateAPITypes(mapComponentsToExpose);
        apiTypesPath = retrieveMfAPITypesPath(tsConfig, remoteOptions);
        import_fs.default.writeFileSync(apiTypesPath, apiTypes);
      }
      if (remoteOptions.deleteTypesFolder) {
        await (0, import_promises.rm)(retrieveMfTypesPath(tsConfig, remoteOptions), {
          recursive: true,
          force: true
        });
      }
      console.log(import_ansi_colors2.default.green("Federated types created correctly"));
    } catch (error2) {
      if (((_a = this.options.remote) == null ? void 0 : _a.abortOnError) === false) {
        console.error(
          import_ansi_colors2.default.red(`Unable to compile federated types, ${error2}`)
        );
      } else {
        throw error2;
      }
    }
  }
  async requestRemoteManifest(remoteInfo) {
    try {
      if (!remoteInfo.url.includes(import_sdk4.MANIFEST_EXT)) {
        return remoteInfo;
      }
      const url = remoteInfo.url;
      const res = await (0, import_axios2.default)({
        method: "get",
        url
      });
      const manifestJson = res.data;
      if (!manifestJson.metaData.types.zip) {
        throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
      }
      const addProtocol = (u) => {
        if (u.startsWith("//")) {
          return `https:${u}`;
        }
        return u;
      };
      let publicPath = "publicPath" in manifestJson.metaData ? manifestJson.metaData.publicPath : new Function(manifestJson.metaData.getPublicPath)();
      if (publicPath === "auto") {
        publicPath = (0, import_sdk4.inferAutoPublicPath)(remoteInfo.url);
      }
      remoteInfo.zipUrl = new URL(
        import_path4.default.join(addProtocol(publicPath), manifestJson.metaData.types.zip)
      ).href;
      if (!manifestJson.metaData.types.api) {
        console.warn(`Can not get ${remoteInfo.name}'s api types url!`);
        remoteInfo.apiTypeUrl = "";
        return remoteInfo;
      }
      remoteInfo.apiTypeUrl = new URL(
        import_path4.default.join(addProtocol(publicPath), manifestJson.metaData.types.api)
      ).href;
      return remoteInfo;
    } catch (_err) {
      fileLog(
        `fetch manifest failed, ${_err}, ${remoteInfo.name} will be ignored`,
        "requestRemoteManifest",
        "error"
      );
      return remoteInfo;
    }
  }
  async consumeTargetRemotes(hostOptions, remoteInfo) {
    if (!remoteInfo.zipUrl) {
      throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
    }
    const typesDownloader = downloadTypesArchive(hostOptions);
    return typesDownloader([remoteInfo.alias, remoteInfo.zipUrl]);
  }
  async downloadAPITypes(remoteInfo, destinationPath) {
    const { apiTypeUrl } = remoteInfo;
    if (!apiTypeUrl) {
      return;
    }
    try {
      const url = apiTypeUrl;
      const res = await import_axios2.default.get(url);
      let apiTypeFile = res.data;
      apiTypeFile = apiTypeFile.replaceAll(
        REMOTE_ALIAS_IDENTIFIER,
        remoteInfo.alias
      );
      const filePath = import_path4.default.join(destinationPath, REMOTE_API_TYPES_FILE_NAME);
      import_fs.default.writeFileSync(filePath, apiTypeFile);
      this.loadedRemoteAPIAlias.push(remoteInfo.alias);
    } catch (err) {
      fileLog(
        `Unable to download "${remoteInfo.name}" api types, ${err}`,
        "consumeTargetRemotes",
        "error"
      );
    }
  }
  consumeAPITypes(hostOptions) {
    if (!this.loadedRemoteAPIAlias.length) {
      return;
    }
    const packageTypes = [];
    const remoteKeys = [];
    const importTypeStr = this.loadedRemoteAPIAlias.sort().map((alias, index) => {
      const remoteKey = `RemoteKeys_${index}`;
      const packageType = `PackageType_${index}`;
      packageTypes.push(`T extends ${remoteKey} ? ${packageType}<T>`);
      remoteKeys.push(remoteKey);
      return `import type { PackageType as ${packageType},RemoteKeys as ${remoteKey} } from './${alias}/apis.d.ts';`;
    }).join("\n");
    const remoteKeysStr = `type RemoteKeys = ${remoteKeys.join(" | ")};`;
    const packageTypesStr = `type PackageType<T, Y=any> = ${[
      ...packageTypes,
      "Y"
    ].join(" :\n")} ;`;
    const pkgsDeclareStr = this.runtimePkgs.map((pkg) => {
      return `declare module "${pkg}" {
      ${remoteKeysStr}
      ${packageTypesStr}
      export function loadRemote<T extends RemoteKeys,Y>(packageName: T): Promise<PackageType<T, Y>>;
      export function loadRemote<T extends string,Y>(packageName: T): Promise<PackageType<T, Y>>;
    }`;
    }).join("\n");
    const fileStr = `${importTypeStr}
    ${pkgsDeclareStr}
    `;
    import_fs.default.writeFileSync(
      import_path4.default.join(
        hostOptions.context,
        hostOptions.typesFolder,
        HOST_API_TYPES_FILE_NAME
      ),
      fileStr
    );
  }
  async consumeArchiveTypes(options) {
    const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(options);
    if (hostOptions.deleteTypesFolder) {
      await (0, import_promises.rm)(hostOptions.typesFolder, {
        recursive: true,
        force: true
      }).catch(
        (error2) => fileLog(
          `Unable to remove types folder, ${error2}`,
          "consumeArchiveTypes",
          "error"
        )
      );
    }
    const downloadPromises = Object.entries(mapRemotesToDownload).map(
      async (item) => {
        const remoteInfo = item[1];
        if (!this.remoteAliasMap[remoteInfo.alias]) {
          const requiredRemoteInfo = await this.requestRemoteManifest(remoteInfo);
          this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
        }
        return this.consumeTargetRemotes(
          hostOptions,
          this.remoteAliasMap[remoteInfo.alias]
        );
      }
    );
    const downloadPromisesResult = await Promise.allSettled(downloadPromises);
    return {
      hostOptions,
      downloadPromisesResult
    };
  }
  async consumeTypes() {
    var _a;
    try {
      const { options } = this;
      if (!options.host) {
        throw new Error("options.host is required if you want to consumeTypes");
      }
      const { mapRemotesToDownload } = retrieveHostConfig(options.host);
      if (!Object.keys(mapRemotesToDownload).length) {
        return;
      }
      const { downloadPromisesResult, hostOptions } = await this.consumeArchiveTypes(options.host);
      if (hostOptions.consumeAPITypes) {
        await Promise.all(
          downloadPromisesResult.map(async (item) => {
            if (item.status === "rejected" || !item.value) {
              return;
            }
            const [alias, destinationPath] = item.value;
            const remoteInfo = this.remoteAliasMap[alias];
            if (!remoteInfo) {
              return;
            }
            await this.downloadAPITypes(remoteInfo, destinationPath);
          })
        );
        this.consumeAPITypes(hostOptions);
      }
      console.log(import_ansi_colors2.default.green("Federated types extraction completed"));
    } catch (err) {
      if (((_a = this.options.host) == null ? void 0 : _a.abortOnError) === false) {
        fileLog(
          `Unable to consume federated types, ${err}`,
          "consumeTypes",
          "error"
        );
      } else {
        throw err;
      }
    }
  }
  async updateTypes(options) {
    var _a, _b, _c;
    const { remoteName, updateMode } = options;
    const hostName = (_c = (_b = (_a = this.options) == null ? void 0 : _a.host) == null ? void 0 : _b.moduleFederationConfig) == null ? void 0 : _c.name;
    if (updateMode === "POSITIVE" /* POSITIVE */ && remoteName === hostName) {
      if (!this.options.remote) {
        return;
      }
      this.generateTypes();
    } else {
      const { remoteAliasMap } = this;
      if (!this.options.host) {
        return;
      }
      const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(
        this.options.host
      );
      const loadedRemoteInfo = Object.values(remoteAliasMap).find(
        (i) => i.name === remoteName
      );
      if (!loadedRemoteInfo) {
        const remoteInfo = Object.values(mapRemotesToDownload).find((item) => {
          return item.name === remoteName;
        });
        if (remoteInfo) {
          if (!this.remoteAliasMap[remoteInfo.alias]) {
            const requiredRemoteInfo = await this.requestRemoteManifest(remoteInfo);
            this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
          }
          await this.consumeTargetRemotes(
            hostOptions,
            this.remoteAliasMap[remoteInfo.alias]
          );
        }
      } else {
        await this.consumeTargetRemotes(hostOptions, loadedRemoteInfo);
      }
    }
  }
};

// packages/dts-plugin/src/core/lib/utils.ts
var import_ansi_colors3 = __toESM(require("ansi-colors"));
function getDTSManagerConstructor(implementation) {
  if (implementation) {
    const NewConstructor = require(implementation);
    return NewConstructor.default ? NewConstructor.default : NewConstructor;
  }
  return DTSManager;
}
var validateOptions = (options) => {
  if (!options.moduleFederationConfig) {
    throw new Error("moduleFederationConfig is required");
  }
};

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var defaultOptions2 = {
  tsConfigPath: "./tsconfig.json",
  typesFolder: "@mf-types",
  compiledTypesFolder: "compiled-types",
  hostRemoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  additionalFilesToCompile: [],
  compilerInstance: "tsc",
  compileInChildProcess: false,
  implementation: "",
  generateAPITypes: false,
  context: process.cwd(),
  abortOnError: true,
  extractRemoteTypes: false,
  extractThirdParty: false
};
var readTsConfig = ({
  tsConfigPath,
  typesFolder,
  compiledTypesFolder,
  context
}) => {
  const resolvedTsConfigPath = (0, import_path5.resolve)(context, tsConfigPath);
  const readResult = import_typescript2.default.readConfigFile(
    resolvedTsConfigPath,
    import_typescript2.default.sys.readFile
  );
  if (readResult.error) {
    throw new Error(readResult.error.messageText.toString());
  }
  const configContent = import_typescript2.default.parseJsonConfigFileContent(
    readResult.config,
    import_typescript2.default.sys,
    (0, import_path5.dirname)(resolvedTsConfigPath)
  );
  const outDir = (0, import_path5.resolve)(
    context,
    configContent.options.outDir || "dist",
    typesFolder,
    compiledTypesFolder
  );
  return {
    ...configContent.options,
    emitDeclarationOnly: true,
    noEmit: false,
    declaration: true,
    outDir
  };
};
var TS_EXTENSIONS = ["ts", "tsx", "vue", "svelte"];
var resolveWithExtension = (exposedPath, context) => {
  if ((0, import_path5.extname)(exposedPath)) {
    return (0, import_path5.resolve)(context, exposedPath);
  }
  for (const extension of TS_EXTENSIONS) {
    const exposedPathWithExtension = (0, import_path5.resolve)(
      context,
      `${exposedPath}.${extension}`
    );
    if ((0, import_fs2.existsSync)(exposedPathWithExtension)) {
      return exposedPathWithExtension;
    }
  }
  return void 0;
};
var resolveExposes = (remoteOptions) => {
  const parsedOptions = import_managers2.utils.parseOptions(
    remoteOptions.moduleFederationConfig.exposes || {},
    (item, key) => ({
      exposePath: Array.isArray(item) ? item[0] : item,
      key
    }),
    (item, key) => ({
      exposePath: Array.isArray(item.import) ? item.import[0] : item.import[0],
      key
    })
  );
  return parsedOptions.reduce(
    (accumulator, item) => {
      const { exposePath, key } = item[1];
      accumulator[key] = resolveWithExtension(exposePath, remoteOptions.context) || resolveWithExtension(
        (0, import_path5.join)(exposePath, "index"),
        remoteOptions.context
      ) || exposePath;
      return accumulator;
    },
    {}
  );
};
var retrieveRemoteConfig = (options) => {
  validateOptions(options);
  const remoteOptions = {
    ...defaultOptions2,
    ...options
  };
  const mapComponentsToExpose = resolveExposes(remoteOptions);
  const tsConfig = readTsConfig(remoteOptions);
  return {
    tsConfig,
    mapComponentsToExpose,
    remoteOptions
  };
};

// packages/dts-plugin/src/core/lib/DtsWorker.ts
var import_lodash2 = __toESM(require("lodash.clonedeepwith"));

// packages/dts-plugin/src/core/rpc/index.ts
var rpc_exports = {};
__export(rpc_exports, {
  RpcExitError: () => RpcExitError,
  RpcGMCallTypes: () => RpcGMCallTypes,
  createRpcWorker: () => createRpcWorker,
  exposeRpc: () => exposeRpc,
  getRpcWorkerData: () => getRpcWorkerData,
  wrapRpc: () => wrapRpc
});

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
var import_process = __toESM(require("process"));

// packages/dts-plugin/src/core/rpc/types.ts
var RpcGMCallTypes = /* @__PURE__ */ ((RpcGMCallTypes2) => {
  RpcGMCallTypes2["CALL"] = "mf_call";
  RpcGMCallTypes2["RESOLVE"] = "mf_resolve";
  RpcGMCallTypes2["REJECT"] = "mf_reject";
  RpcGMCallTypes2["EXIT"] = "mf_exit";
  return RpcGMCallTypes2;
})(RpcGMCallTypes || {});

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
function exposeRpc(fn) {
  const sendMessage = (message) => new Promise((resolve4, reject) => {
    if (!import_process.default.send) {
      reject(new Error(`Process ${import_process.default.pid} doesn't have IPC channels`));
    } else if (!import_process.default.connected) {
      reject(
        new Error(`Process ${import_process.default.pid} doesn't have open IPC channels`)
      );
    } else {
      import_process.default.send(message, void 0, void 0, (error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve4(void 0);
        }
      });
    }
  });
  const handleMessage = async (message) => {
    if (message.type === "mf_call" /* CALL */) {
      if (!import_process.default.send) {
        return;
      }
      let value, error2;
      try {
        value = await fn(...message.args);
      } catch (fnError) {
        error2 = fnError;
      }
      try {
        if (error2) {
          await sendMessage({
            type: "mf_reject" /* REJECT */,
            id: message.id,
            error: error2
          });
        } else {
          await sendMessage({
            type: "mf_resolve" /* RESOLVE */,
            id: message.id,
            value
          });
        }
      } catch (sendError) {
        if (error2) {
          if (error2 instanceof Error) {
            console.error(error2);
          }
        }
        console.error(sendError);
      }
    }
  };
  import_process.default.on("message", handleMessage);
}

// packages/dts-plugin/src/core/rpc/rpc-error.ts
var RpcExitError = class extends Error {
  constructor(message, code, signal) {
    super(message);
    this.code = code;
    this.signal = signal;
    this.name = "RpcExitError";
  }
};

// packages/dts-plugin/src/core/rpc/wrap-rpc.ts
function createControlledPromise() {
  let resolve4 = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((aResolve, aReject) => {
    resolve4 = aResolve;
    reject = aReject;
  });
  return {
    promise,
    resolve: resolve4,
    reject
  };
}
function wrapRpc(childProcess, options) {
  return async (...args) => {
    if (!childProcess.send) {
      throw new Error(`Process ${childProcess.pid} doesn't have IPC channels`);
    } else if (!childProcess.connected) {
      throw new Error(
        `Process ${childProcess.pid} doesn't have open IPC channels`
      );
    }
    const { id, once } = options;
    const {
      promise: resultPromise,
      resolve: resolveResult,
      reject: rejectResult
    } = createControlledPromise();
    const {
      promise: sendPromise,
      resolve: resolveSend,
      reject: rejectSend
    } = createControlledPromise();
    const handleMessage = (message) => {
      if ((message == null ? void 0 : message.id) === id) {
        if (message.type === "mf_resolve" /* RESOLVE */) {
          resolveResult(message.value);
        } else if (message.type === "mf_reject" /* REJECT */) {
          rejectResult(message.error);
        }
      }
      if (once && (childProcess == null ? void 0 : childProcess.kill)) {
        childProcess.kill("SIGTERM");
      }
    };
    const handleClose = (code, signal) => {
      rejectResult(
        new RpcExitError(
          code ? `Process ${childProcess.pid} exited with code ${code}${signal ? ` [${signal}]` : ""}` : `Process ${childProcess.pid} exited${signal ? ` [${signal}]` : ""}`,
          code,
          signal
        )
      );
      removeHandlers();
    };
    const removeHandlers = () => {
      childProcess.off("message", handleMessage);
      childProcess.off("close", handleClose);
    };
    if (once) {
      childProcess.once("message", handleMessage);
    } else {
      childProcess.on("message", handleMessage);
    }
    childProcess.on("close", handleClose);
    childProcess.send(
      {
        type: "mf_call" /* CALL */,
        id,
        args
      },
      (error2) => {
        if (error2) {
          rejectSend(error2);
          removeHandlers();
        } else {
          resolveSend(void 0);
        }
      }
    );
    return sendPromise.then(() => resultPromise);
  };
}

// packages/dts-plugin/src/core/rpc/rpc-worker.ts
var child_process = __toESM(require("child_process"));
var process3 = __toESM(require("process"));
var import_crypto = require("crypto");
var FEDERATION_WORKER_DATA_ENV_KEY = "VMOK_WORKER_DATA_ENV";
function createRpcWorker(modulePath, data, memoryLimit, once) {
  const options = {
    env: {
      ...process3.env,
      [FEDERATION_WORKER_DATA_ENV_KEY]: JSON.stringify(data || {})
    },
    stdio: ["inherit", "inherit", "inherit", "ipc"],
    serialization: "advanced"
  };
  if (memoryLimit) {
    options.execArgv = [`--max-old-space-size=${memoryLimit}`];
  }
  let childProcess, remoteMethod;
  const id = (0, import_crypto.randomUUID)();
  const worker = {
    connect(...args) {
      if (childProcess && !childProcess.connected) {
        childProcess.send({
          type: "mf_exit" /* EXIT */,
          id
        });
        childProcess = void 0;
        remoteMethod = void 0;
      }
      if (!(childProcess == null ? void 0 : childProcess.connected)) {
        childProcess = child_process.fork(modulePath, options);
        remoteMethod = wrapRpc(childProcess, { id, once });
      }
      if (!remoteMethod) {
        return Promise.reject(
          new Error("Worker is not connected - cannot perform RPC.")
        );
      }
      return remoteMethod(...args);
    },
    terminate() {
      var _a;
      (_a = childProcess == null ? void 0 : childProcess.send) == null ? void 0 : _a.call(childProcess, {
        type: "mf_exit" /* EXIT */,
        id
      });
      childProcess = void 0;
      remoteMethod = void 0;
    },
    get connected() {
      return Boolean(childProcess == null ? void 0 : childProcess.connected);
    },
    get process() {
      return childProcess;
    },
    get id() {
      return id;
    }
  };
  return worker;
}
function getRpcWorkerData() {
  return JSON.parse(process3.env[FEDERATION_WORKER_DATA_ENV_KEY] || "{}");
}

// packages/dts-plugin/src/dev-worker/forkDevWorker.ts
var import_sdk5 = require("@module-federation/sdk");
var DEFAULT_LOCAL_IPS = ["localhost", "127.0.0.1"];
function getIpFromEntry(entry) {
  let ip;
  entry.replace(/https?:\/\/([0-9|.]+|localhost):/, (str, matched) => {
    ip = matched;
    return str;
  });
  if (ip) {
    return DEFAULT_LOCAL_IPS.includes(ip) ? getIPV4() : ip;
  }
}
var typesManager;
var serverAddress;
var moduleServer;
var cacheOptions;
function getLocalRemoteNames(options, encodeNameIdentifier) {
  if (!options) {
    return [];
  }
  const { mapRemotesToDownload } = retrieveHostConfig(options);
  return Object.keys(mapRemotesToDownload).reduce(
    (sum, remoteModuleName) => {
      const remoteInfo = mapRemotesToDownload[remoteModuleName];
      const name = encodeNameIdentifier ? (0, import_sdk5.decodeName)(remoteInfo.name, encodeNameIdentifier) : remoteInfo.name;
      const ip = getIpFromEntry(remoteInfo.url);
      if (!ip) {
        return sum;
      }
      sum.push({
        name,
        entry: remoteInfo.url,
        ip
      });
      return sum;
    },
    []
  );
}
async function updateCallback({
  updateMode,
  name,
  remoteTypeTarPath
}) {
  const { disableHotTypesReload, disableLiveReload } = cacheOptions || {};
  fileLog(
    `sync remote module ${name}, types to vmok ${cacheOptions == null ? void 0 : cacheOptions.name},typesManager.updateTypes run`,
    "forkDevWorker",
    "info"
  );
  if (!disableLiveReload && moduleServer) {
    moduleServer.update({
      updateKind: "RELOAD_PAGE" /* RELOAD_PAGE */,
      updateMode: "PASSIVE" /* PASSIVE */
    });
  }
  if (!disableHotTypesReload && typesManager) {
    await typesManager.updateTypes({
      updateMode,
      remoteName: name,
      remoteTarPath: remoteTypeTarPath
    });
  }
}
async function forkDevWorker(options, action) {
  if (!typesManager) {
    const { name, remote, host, extraOptions } = options;
    const DTSManagerConstructor = getDTSManagerConstructor(
      remote == null ? void 0 : remote.implementation
    );
    typesManager = new DTSManagerConstructor({
      remote,
      host,
      extraOptions
    });
    if (!options.disableHotTypesReload && remote) {
      const { remoteOptions, tsConfig } = retrieveRemoteConfig(remote);
      const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
      const mfTypesZipPath = retrieveTypesZipPath(mfTypesPath, remoteOptions);
      await Promise.all([
        createKoaServer({
          typeTarPath: mfTypesZipPath
        }).then((res) => {
          serverAddress = res.serverAddress;
        }),
        typesManager.generateTypes()
      ]).catch((err) => {
        fileLog(
          `${name} module generateTypes done, localServerAddress:  ${JSON.stringify(
            err
          )}`,
          "forkDevWorker",
          "error"
        );
      });
      fileLog(
        `${name} module generateTypes done, localServerAddress:  ${serverAddress}`,
        "forkDevWorker",
        "info"
      );
    }
    moduleServer = new ModuleFederationDevServer({
      name,
      remotes: getLocalRemoteNames(
        host,
        extraOptions == null ? void 0 : extraOptions["encodeNameIdentifier"]
      ),
      updateCallback,
      remoteTypeTarPath: `${serverAddress}/${DEFAULT_TAR_NAME}`
    });
    cacheOptions = options;
  }
  if (action === "update" && cacheOptions) {
    fileLog(
      `remoteModule ${cacheOptions.name} receive devWorker update, start typesManager.updateTypes `,
      "forkDevWorker",
      "info"
    );
    if (!cacheOptions.disableLiveReload) {
      moduleServer == null ? void 0 : moduleServer.update({
        updateKind: "RELOAD_PAGE" /* RELOAD_PAGE */,
        updateMode: "POSITIVE" /* POSITIVE */
      });
    }
    if (!cacheOptions.disableHotTypesReload) {
      typesManager == null ? void 0 : typesManager.updateTypes({
        updateMode: "POSITIVE" /* POSITIVE */,
        remoteName: cacheOptions.name
      }).then(() => {
        moduleServer == null ? void 0 : moduleServer.update({
          updateKind: "UPDATE_TYPE" /* UPDATE_TYPE */,
          updateMode: "POSITIVE" /* POSITIVE */
        });
      });
    }
  }
}
process.on("message", (message) => {
  fileLog(
    `ChildProcess(${process.pid}), message: ${JSON.stringify(message)} `,
    "forkDevWorker",
    "info"
  );
  if (message.type === rpc_exports.RpcGMCallTypes.EXIT) {
    fileLog(
      `ChildProcess(${process.pid}) SIGTERM, Federation DevServer will exit...`,
      "forkDevWorker",
      "error"
    );
    moduleServer.exit();
    process.exit(0);
  }
});
rpc_exports.exposeRpc(forkDevWorker);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  forkDevWorker
});
