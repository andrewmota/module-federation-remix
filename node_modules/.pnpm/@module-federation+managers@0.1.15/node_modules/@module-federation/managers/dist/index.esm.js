import path from 'path';
import { MFModuleType, generateExposeFilename, composeKeyWithSeparator, parseEntry } from '@module-federation/sdk';
import finder from 'find-pkg';
import fs from 'fs';
import fs$1 from 'fs-extra';

function _class_call_check$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$4(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$4(Constructor, staticProps);
    return Constructor;
}
function _define_property$4(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var BasicPluginOptionsManager = /*#__PURE__*/ function() {
    function BasicPluginOptionsManager() {
        _class_call_check$4(this, BasicPluginOptionsManager);
        _define_property$4(this, "_options", void 0);
    }
    _create_class$4(BasicPluginOptionsManager, [
        {
            key: "enable",
            get: function get() {
                return Boolean(this._options);
            }
        },
        {
            key: "options",
            get: function get() {
                return this._options;
            }
        },
        {
            key: "init",
            value: function init(options, extraArgs) {
                this._options = options;
            }
        },
        {
            key: "setOptions",
            value: function setOptions(options) {
                this._options = options;
            }
        }
    ]);
    return BasicPluginOptionsManager;
}();

function _class_call_check$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$3(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$3(Constructor, staticProps);
    return Constructor;
}
function _define_property$3(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var PKGJsonManager = /*#__PURE__*/ function() {
    function PKGJsonManager() {
        _class_call_check$3(this, PKGJsonManager);
        _define_property$3(this, "_pkg", void 0);
    }
    _create_class$3(PKGJsonManager, [
        {
            key: "setPKGJson",
            value: function setPKGJson(pkg) {
                this._pkg = pkg;
            }
        },
        {
            key: "readPKGJson",
            value: function readPKGJson() {
                var ctx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd();
                if (this._pkg) {
                    return this._pkg;
                }
                try {
                    // eslint-disable-next-line no-restricted-globals
                    var pkg = JSON.parse(fs.readFileSync(path.resolve(ctx, 'package.json'), 'utf8'));
                    this._pkg = pkg;
                    return pkg;
                } catch (_err) {
                    try {
                        var pkg1 = finder.sync(ctx);
                        this._pkg = pkg1;
                        return pkg1;
                    } catch (err) {
                        console.error(err);
                        return {};
                    }
                }
            }
        },
        {
            key: "getExposeGarfishModuleType",
            value: function getExposeGarfishModuleType() {
                var ctx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : process.cwd();
                var _pkg_mf;
                var pkg = this.readPKGJson(ctx);
                return (pkg === null || pkg === void 0 ? void 0 : (_pkg_mf = pkg['mf']) === null || _pkg_mf === void 0 ? void 0 : _pkg_mf.type) === MFModuleType.NPM ? MFModuleType.NPM : MFModuleType.APP;
            }
        }
    ]);
    return PKGJsonManager;
}();

var LOCAL_BUILD_VERSION = 'local';

function _array_like_to_array$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$2(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit$2(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array$2(arr, i) {
    return _array_with_holes$2(arr) || _iterable_to_array_limit$2(arr, i) || _unsupported_iterable_to_array$2(arr, i) || _non_iterable_rest$2();
}
function _unsupported_iterable_to_array$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);
}
function processFn(options, normalizeSimple, normalizeOptions, fn) {
    var object = function(obj) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array$2(_step.value, 2), key = _step_value[0], value = _step_value[1];
                if (typeof value === 'string') {
                    fn(key, normalizeSimple(value, key));
                } else {
                    fn(key, normalizeOptions(value, key));
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    var array = function(items) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var item = _step.value;
                if (typeof item === 'string') {
                    fn(item, normalizeSimple(item, item));
                } else if (item && typeof item === 'object') {
                    object(item);
                } else {
                    throw new Error('Unexpected options format');
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    if (!options) {
        return;
    } else if (Array.isArray(options)) {
        array(options);
    } else if (typeof options === 'object') {
        object(options);
    } else {
        throw new Error('Unexpected options format');
    }
}
function parseOptions(options, normalizeSimple, normalizeOptions) {
    var items = [];
    processFn(options, normalizeSimple, normalizeOptions, function(key, value) {
        items.push([
            key,
            value
        ]);
    });
    return items;
}
function getBuildVersion() {
    if (process.env['MF_BUILD_VERSION']) {
        return process.env['MF_BUILD_VERSION'];
    }
    var pkg = new PKGJsonManager().readPKGJson();
    if ((pkg === null || pkg === void 0 ? void 0 : pkg['version']) && typeof pkg['version'] === 'string') {
        return pkg['version'];
    }
    return LOCAL_BUILD_VERSION;
}
function getBuildName() {
    return process.env['MF_BUILD_NAME'];
}
// RegExp for version string
var VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;
function isRequiredVersion(str) {
    return VERSION_PATTERN_REGEXP.test(str);
}

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  parseOptions: parseOptions,
  getBuildVersion: getBuildVersion,
  getBuildName: getBuildName,
  isRequiredVersion: isRequiredVersion
});

function _array_like_to_array$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes$1(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array$1(arr);
}
function _assert_this_initialized$2(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _class_call_check$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$2(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);
    return Constructor;
}
function _define_property$2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of$2(o) {
    _get_prototype_of$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$2(o);
}
function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$2(subClass, superClass);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return$2(self, call) {
    if (call && (_type_of$2(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$2(self);
}
function _set_prototype_of$2(o, p) {
    _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$2(o, p);
}
function _sliced_to_array$1(arr, i) {
    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$1(arr, i) || _non_iterable_rest$1();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_spread();
}
function _type_of$2(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);
}
function _is_native_reflect_construct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super$2(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct$2();
    return function _createSuperInternal() {
        var Super = _get_prototype_of$2(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of$2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return$2(this, result);
    };
}
function normalizeExposeModuleName(exposeKey) {
    var relativePath = path.relative('.', exposeKey);
    if (!relativePath) {
        return 'ExposeEntry';
    }
    return relativePath;
}
var ContainerManager = /*#__PURE__*/ function(BasicPluginOptionsManager) {
    _inherits$2(ContainerManager, BasicPluginOptionsManager);
    var _super = _create_super$2(ContainerManager);
    function ContainerManager() {
        _class_call_check$2(this, ContainerManager);
        var _this;
        _this = _super.apply(this, arguments);
        _define_property$2(_assert_this_initialized$2(_this), "_manifestModuleInfos", void 0);
        _define_property$2(_assert_this_initialized$2(_this), "_parsedOptions", void 0);
        return _this;
    }
    _create_class$2(ContainerManager, [
        {
            key: "enable",
            get: function get() {
                return Boolean(this.options.name && this.options.exposes && (Array.isArray(this.options.exposes) ? this.options.exposes.length > 0 : Object.keys(this.options.exposes).length > 0));
            }
        },
        {
            key: "globalEntryName",
            get: function get() {
                var _this_options = this.options, name = _this_options.name, library = _this_options.library;
                if (library) {
                    if (typeof library.name === 'string') {
                        return library.name;
                    }
                    return name;
                }
                return name;
            }
        },
        {
            key: "containerPluginExposesOptions",
            get: function get() {
                var exposes = this.options.exposes;
                var parsedOptions = parseOptions(exposes, function(item, key) {
                    return {
                        import: Array.isArray(item) ? item : [
                            item
                        ],
                        name: generateExposeFilename(key, false)
                    };
                }, function(item, key) {
                    return {
                        import: Array.isArray(item.import) ? item.import : [
                            item.import
                        ],
                        name: item.name || generateExposeFilename(key, false)
                    };
                });
                return parsedOptions.reduce(function(sum, item) {
                    var _item = _sliced_to_array$1(item, 2), exposeKey = _item[0], exposeObj = _item[1];
                    sum[exposeKey] = exposeObj;
                    return sum;
                }, {});
            }
        },
        {
            key: "exposeFileNameImportMap",
            get: // { '.' : './src/Button.jsx' } => { '__federation_expose_Component' : ['src/Buttton'] }
            function get() {
                var exposes = this.options.exposes;
                var parsedOptions = parseOptions(exposes, function(item, key) {
                    return {
                        import: Array.isArray(item) ? item : [
                            item
                        ],
                        name: generateExposeFilename(key, false)
                    };
                }, function(item, key) {
                    return {
                        import: Array.isArray(item.import) ? item.import : [
                            item.import
                        ],
                        name: item.name || generateExposeFilename(key, false)
                    };
                });
                return parsedOptions.reduce(function(sum, item) {
                    var _item = _sliced_to_array$1(item, 2); _item[0]; var exposeObj = _item[1];
                    var name = exposeObj.name, importPath = exposeObj.import;
                    sum[name] = importPath;
                    return sum;
                }, {});
            }
        },
        {
            key: "exposeObject",
            get: // { '.' : './src/Button.jsx' } => { '.' : ['src/Button'] }
            function get() {
                var parsedOptions = this._parseOptions();
                return parsedOptions.reduce(function(sum, item) {
                    var _item = _sliced_to_array$1(item, 2), exposeKey = _item[0], exposeObject = _item[1];
                    sum[exposeKey] = [];
                    exposeObject.import.forEach(function(item) {
                        var relativePath = path.relative('.', item.replace(path.extname(item), ''));
                        sum[exposeKey].push(relativePath);
                    });
                    return sum;
                }, {});
            }
        },
        {
            key: "exposeFiles",
            get: // { '.' : './src/Button.jsx' } => ['./src/Button.jsx']
            function get() {
                var parsedOptions = this._parseOptions();
                return parsedOptions.reduce(function(sum, item) {
                    var _sum;
                    var _item = _sliced_to_array$1(item, 2); _item[0]; var exposeObject = _item[1];
                    (_sum = sum).push.apply(_sum, _to_consumable_array(exposeObject.import));
                    return sum;
                }, []);
            }
        },
        {
            key: "manifestModuleInfos",
            get: function get() {
                if (this._manifestModuleInfos) {
                    return this._manifestModuleInfos;
                }
                // { '.' : './src/Button.jsx' } => { '.' : {  name: 'ExposeEntry', file: './src/Button.jsx', requires: {} } }
                var parsedOptions = this._parseOptions();
                this._manifestModuleInfos = parsedOptions.reduce(function(sum, item) {
                    var _item = _sliced_to_array$1(item, 2), exposeKey = _item[0], exposeObject = _item[1];
                    sum[exposeKey] = {
                        name: exposeObject.name || normalizeExposeModuleName(exposeKey),
                        file: exposeObject.import
                    };
                    return sum;
                }, {});
                return this._manifestModuleInfos;
            }
        },
        {
            key: "webpackEntry",
            get: // { '.' : './src/Button.jsx' } => { index: ['./src/Button.jsx'] }
            function get() {
                return Object.values(this.manifestModuleInfos).reduce(function(sum, cur) {
                    var entry = cur.name === 'ExposeEntry' ? 'index' : cur.name.slice(0, 1).toLowerCase() + cur.name.slice(1);
                    sum[entry] = cur.file;
                    return sum;
                }, {});
            }
        },
        {
            key: "_parseOptions",
            value: function _parseOptions() {
                if (this._parsedOptions) {
                    return this._parsedOptions;
                }
                this._parsedOptions = parseOptions(this.options.exposes, function(item) {
                    return {
                        import: Array.isArray(item) ? item : [
                            item
                        ],
                        name: undefined
                    };
                }, function(item) {
                    return {
                        import: Array.isArray(item.import) ? item.import : [
                            item.import
                        ],
                        name: undefined
                    };
                });
                return this._parsedOptions;
            }
        },
        {
            key: "init",
            value: function init(options) {
                this.setOptions(options);
                this.validate(options.name);
            }
        },
        {
            key: "validate",
            value: function validate(name) {
                if (!name) {
                    throw new Error("container name can not be empty!");
                }
            }
        }
    ]);
    return ContainerManager;
}(BasicPluginOptionsManager);

function _assert_this_initialized$1(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _class_call_check$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$1(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
}
function _define_property$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of$1(o) {
    _get_prototype_of$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of$1(o);
}
function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$1(subClass, superClass);
}
function _object_spread$1(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$1(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props$1(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys$1(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _possible_constructor_return$1(self, call) {
    if (call && (_type_of$1(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized$1(self);
}
function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$1(o, p);
}
function _type_of$1(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _is_native_reflect_construct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super$1(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct$1();
    return function _createSuperInternal() {
        var Super = _get_prototype_of$1(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of$1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return$1(this, result);
    };
}
function getEntry(remoteObj) {
    if (typeof remoteObj === 'string') {
        return remoteObj;
    }
    if (typeof remoteObj.external === 'string') {
        return remoteObj.external;
    }
    throw new Error('Not support "array" remote value yet!');
}
var RemoteManager = /*#__PURE__*/ function(BasicPluginOptionsManager) {
    _inherits$1(RemoteManager, BasicPluginOptionsManager);
    var _super = _create_super$1(RemoteManager);
    function RemoteManager() {
        _class_call_check$1(this, RemoteManager);
        var _this;
        _this = _super.apply(this, arguments);
        _define_property$1(_assert_this_initialized$1(_this), "normalizedOptions", {});
        return _this;
    }
    _create_class$1(RemoteManager, [
        {
            key: "enable",
            get: function get() {
                return Boolean(this.remotes && (Array.isArray(this.remotes) ? this.remotes.length > 0 : Object.keys(this.remotes).length > 0));
            }
        },
        {
            key: "statsRemoteWithEmptyUsedIn",
            get: function get() {
                var _this = this;
                var name = this.options.name;
                return Object.keys(this.normalizedOptions).reduce(function(sum, cur) {
                    var normalizedOption = _this.normalizedOptions[cur];
                    var curObj;
                    if ('entry' in normalizedOption) {
                        curObj = {
                            entry: normalizedOption.entry,
                            alias: normalizedOption.alias,
                            moduleName: normalizedOption.name,
                            federationContainerName: normalizedOption.name,
                            consumingFederationContainerName: name,
                            usedIn: []
                        };
                    } else {
                        curObj = {
                            alias: normalizedOption.alias,
                            moduleName: normalizedOption.name,
                            version: normalizedOption.version,
                            federationContainerName: normalizedOption.name,
                            consumingFederationContainerName: name,
                            usedIn: []
                        };
                    }
                    sum.push(curObj);
                    return sum;
                }, []);
            }
        },
        {
            key: "dtsRemotes",
            get: // 'micro-app-sub3': 'app:@garfish/micro-app-sub3:0.0.4',
            // ↓↓↓
            //  {
            //   'micro-app-sub3': @garfish/micro-app-sub3:0.0.4
            // }
            function get() {
                var _this = this;
                return Object.keys(this.normalizedOptions).reduce(function(sum, remoteAlias) {
                    var remoteInfo = _this.normalizedOptions[remoteAlias];
                    sum[remoteAlias] = composeKeyWithSeparator(remoteInfo.name, 'entry' in remoteInfo ? remoteInfo.entry : remoteInfo.version);
                    return sum;
                }, {});
            }
        },
        {
            key: "remotes",
            get: function get() {
                return this.options.remotes;
            }
        },
        {
            // INFO: only support remoteType: script now
            key: "normalizeOptions",
            value: function normalizeOptions() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.normalizedOptions = Object.keys(options).reduce(function(sum, remoteAlias) {
                    if (Array.isArray(options)) {
                        return sum;
                    }
                    var remoteInfo = options[remoteAlias];
                    if (Array.isArray(remoteInfo)) {
                        return sum;
                    }
                    var parsedOptions;
                    try {
                        parsedOptions = parseEntry(typeof remoteInfo === 'string' ? remoteInfo : getEntry(remoteInfo), '', '@');
                    } catch (e) {
                    // noop
                    }
                    if (!parsedOptions) {
                        return sum;
                    }
                    sum[remoteAlias] = _object_spread_props$1(_object_spread$1({}, parsedOptions), {
                        alias: remoteAlias,
                        shareScope: typeof remoteInfo === 'object' ? remoteInfo.shareScope || 'default' : 'default'
                    });
                    return sum;
                }, {});
            }
        },
        {
            key: "init",
            value: function init(options) {
                this.setOptions(options);
                this.normalizeOptions(options.remotes);
            }
        }
    ]);
    return RemoteManager;
}(BasicPluginOptionsManager);

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct();
    return function _createSuperInternal() {
        var Super = _get_prototype_of(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return(this, result);
    };
}
var SharedManager = /*#__PURE__*/ function(BasicPluginOptionsManager) {
    _inherits(SharedManager, BasicPluginOptionsManager);
    var _super = _create_super(SharedManager);
    function SharedManager() {
        _class_call_check(this, SharedManager);
        var _this;
        _this = _super.apply(this, arguments);
        _define_property(_assert_this_initialized(_this), "normalizedOptions", {});
        return _this;
    }
    _create_class(SharedManager, [
        {
            key: "enable",
            get: function get() {
                return Boolean(Object.keys(this.sharedPluginOptions.shared).length);
            }
        },
        {
            key: "sharedPluginOptions",
            get: function get() {
                var normalizedShared = this.normalizedOptions;
                var shared = Object.keys(normalizedShared).reduce(function(sum, cur) {
                    var _normalizedShared_cur = normalizedShared[cur], singleton = _normalizedShared_cur.singleton, requiredVersion = _normalizedShared_cur.requiredVersion, version = _normalizedShared_cur.version, eager = _normalizedShared_cur.eager, shareScope = _normalizedShared_cur.shareScope;
                    sum[cur] = {
                        singleton: singleton,
                        requiredVersion: requiredVersion,
                        version: version,
                        eager: eager,
                        shareScope: shareScope
                    };
                    return sum;
                }, {});
                return {
                    shared: shared,
                    shareScope: this.options.shareScope || 'default'
                };
            }
        },
        {
            key: "findPkg",
            value: function findPkg1(name, shareConfig) {
                try {
                    var pkgPath = '';
                    var depName = name;
                    if (shareConfig.import) {
                        if (path.isAbsolute(shareConfig.import)) {
                            pkgPath = shareConfig.import;
                        } else if (shareConfig.import.startsWith('.')) {
                            pkgPath = path.resolve(process.cwd(), shareConfig.import);
                        }
                    } else {
                        if (shareConfig.packageName) {
                            depName = shareConfig.packageName;
                        }
                    }
                    pkgPath = pkgPath || require.resolve(depName, {
                        paths: [
                            process.cwd()
                        ]
                    });
                    var pkgJsonPath = finder.sync(pkgPath);
                    return {
                        pkg: JSON.parse(fs$1.readFileSync(pkgJsonPath, 'utf-8')),
                        path: '',
                        pkgPath: ''
                    };
                } catch (err) {
                    return {
                        pkg: {},
                        path: '',
                        pkgPath: ''
                    };
                }
            }
        },
        {
            key: "transformSharedConfig",
            value: function transformSharedConfig(sharedConfig) {
                var defaultSharedConfig = {
                    singleton: true,
                    requiredVersion: undefined,
                    shareScope: 'default'
                };
                return _object_spread({}, defaultSharedConfig, sharedConfig);
            }
        },
        {
            key: "normalizeOptions",
            value: function normalizeOptions(options) {
                var _this = this;
                var normalizedShared = {};
                var sharedOptions = parseOptions(options, function(item, key) {
                    if (typeof item !== 'string') throw new Error('Unexpected array in shared');
                    var config = item === key || !isRequiredVersion(item) ? {
                        import: item
                    } : {
                        import: key,
                        requiredVersion: item
                    };
                    return config;
                }, function(item) {
                    return item;
                });
                sharedOptions.forEach(function(item) {
                    var _item = _sliced_to_array(item, 2), sharedName = _item[0], sharedOptions = _item[1];
                    var pkgInfo = _this.findPkg(sharedName, sharedOptions);
                    var sharedConfig = _this.transformSharedConfig(sharedOptions[sharedName]);
                    normalizedShared[sharedName] = _object_spread_props(_object_spread({}, sharedConfig), {
                        requiredVersion: typeof sharedConfig.requiredVersion !== 'undefined' ? sharedConfig.requiredVersion : "^".concat(pkgInfo.pkg['version']),
                        name: sharedName,
                        version: pkgInfo.pkg['version'],
                        eager: Boolean(sharedConfig.eager)
                    });
                });
                this.normalizedOptions = normalizedShared;
            }
        },
        {
            key: "init",
            value: function init(options) {
                this.setOptions(options);
                this.normalizeOptions(options.shared);
            }
        }
    ]);
    return SharedManager;
}(BasicPluginOptionsManager);

var types = /*#__PURE__*/Object.freeze({
  __proto__: null
});

export { BasicPluginOptionsManager, ContainerManager, PKGJsonManager, RemoteManager, SharedManager, types, utils };
