"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoistContainerReferences = void 0;
const ContainerEntryModule_1 = __importDefault(require("./ContainerEntryModule"));
/**
 * This class is used to hoist container references in the code.
 * @constructor
 */
class HoistContainerReferences {
    constructor(name) {
        this.containerName = name;
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap('HoistContainerReferences', (compilation) => {
            compilation.hooks.afterOptimizeChunks.tap('HoistContainerReferences', (chunks) => {
                for (const chunk of chunks) {
                    if (this.chunkContainsContainerEntryModule(chunk, compilation)) {
                        this.hoistModulesInChunk(chunk, compilation);
                    }
                }
            });
        });
    }
    chunkContainsContainerEntryModule(chunk, compilation) {
        for (const module of compilation.chunkGraph.getChunkModulesIterable(chunk)) {
            if (module instanceof ContainerEntryModule_1.default) {
                return true;
            }
        }
        return false;
    }
    hoistModulesInChunk(chunk, compilation) {
        const chunkGraph = compilation.chunkGraph;
        const runtimeChunks = this.getRuntimeChunks(chunk, compilation);
        for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
            if (!chunk.hasRuntime() &&
                (!this.containerName ||
                    (chunk.name !== this.containerName &&
                        chunk.name !== this.containerName + '_partial'))) {
                chunkGraph.disconnectChunkAndModule(chunk, module);
            }
            for (const runtimeChunk of runtimeChunks) {
                if (chunkGraph.isModuleInChunk(module, runtimeChunk))
                    continue;
                chunkGraph.connectChunkAndModule(runtimeChunk, module);
            }
        }
    }
    getRuntimeChunks(chunk, compilation) {
        const runtimeChunks = [];
        for (const c of compilation.chunks) {
            if (c.hasRuntime() && c !== chunk) {
                runtimeChunks.push(c);
            }
        }
        return runtimeChunks;
    }
}
exports.HoistContainerReferences = HoistContainerReferences;
exports.default = HoistContainerReferences;
//# sourceMappingURL=HoistContainerReferencesPlugin.js.map