"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// packages/third-party-dts-extractor/src/ThirdPartyExtractor.ts
var _findpkg = require('find-pkg'); var _findpkg2 = _interopRequireDefault(_findpkg);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _resolve = require('resolve'); var _resolve2 = _interopRequireDefault(_resolve);

// packages/third-party-dts-extractor/src/utils.ts
function getTypedName(name) {
  return `@types/${name.replace(/^@/, "").replace("/", "__")}`;
}

// packages/third-party-dts-extractor/src/ThirdPartyExtractor.ts
var ignoredPkgs = ["typescript"];
var ThirdPartyExtractor = class {
  constructor(destDir, context = process.cwd()) {
    this.destDir = destDir;
    this.context = context;
    this.pkgs = {};
    this.pattern = /(from|import\()\s*['"]([^'"]+)['"]/g;
  }
  addPkgs(pkgName, dirName) {
    if (ignoredPkgs.includes(pkgName)) {
      return;
    }
    this.pkgs[pkgName] = dirName;
  }
  inferPkgDir(importPath) {
    if (this.pkgs[importPath]) {
      return;
    }
    if (_path2.default.isAbsolute(importPath)) {
      return;
    }
    if (importPath.startsWith(".")) {
      return;
    }
    try {
      const pkgJsonPath = _findpkg2.default.sync(
        __require.resolve(importPath, { paths: [this.context] })
      );
      const dir = _path2.default.dirname(pkgJsonPath);
      const pkg = JSON.parse(_fsextra2.default.readFileSync(pkgJsonPath, "utf-8"));
      const types = pkg.types || pkg.typings;
      if (dir === this.context) {
        return;
      }
      if (types) {
        this.addPkgs(pkg.name, dir);
        return dir;
      } else if (_fsextra2.default.existsSync(_path2.default.resolve(dir, "index.d.ts"))) {
        this.addPkgs(pkg.name, dir);
        return dir;
      } else {
        const typedPkgName = getTypedName(pkg.name);
        const typedPkgJsonPath = _findpkg2.default.sync(
          _resolve2.default.sync(`${typedPkgName}/package.json`, {
            basedir: this.context
          })
        );
        const typedDir = _path2.default.dirname(typedPkgJsonPath);
        _fsextra2.default.readFileSync(typedPkgJsonPath, "utf-8");
        this.addPkgs(typedPkgName, typedDir);
        return typedDir;
      }
    } catch (_err) {
      return;
    }
  }
  collectPkgs(str) {
    const { pattern } = this;
    let match;
    const imports = /* @__PURE__ */ new Set();
    while ((match = pattern.exec(str)) !== null) {
      imports.add(match[2]);
    }
    [...imports].forEach((importPath) => {
      this.inferPkgDir(importPath);
    });
  }
  copyDts() {
    if (!Object.keys(this.pkgs).length) {
      return;
    }
    _fsextra2.default.ensureDirSync(this.destDir);
    const copyFiles = (srcDir, destDir) => {
      if (srcDir.startsWith(".")) {
        return;
      }
      _fsextra2.default.readdirSync(srcDir).forEach((file) => {
        const fullPath = _path2.default.join(srcDir, file);
        if (["node_modules", "bin"].includes(file)) {
          return;
        }
        if (_fsextra2.default.lstatSync(fullPath).isDirectory()) {
          const destFullPath = _path2.default.join(destDir, file);
          try {
            if (!_fsextra2.default.existsSync(destFullPath)) {
              _fsextra2.default.mkdirSync(destFullPath);
            }
          } catch (_err) {
          }
          copyFiles(fullPath, destFullPath);
        } else {
          if (fullPath.endsWith(".d.ts") || fullPath.endsWith("package.json")) {
            _fsextra2.default.copyFileSync(fullPath, _path2.default.join(destDir, file));
          }
        }
      });
    };
    Object.keys(this.pkgs).forEach((pkgName) => {
      const pkgDir = this.pkgs[pkgName];
      const destDir = _path2.default.resolve(this.destDir, pkgName);
      _fsextra2.default.ensureDirSync(destDir);
      copyFiles(pkgDir, destDir);
    });
  }
};


exports.ThirdPartyExtractor = ThirdPartyExtractor;
